pipeline {
    agent {
        kubernetes {
            yamlFile 'kaniko-builder-harbor.yaml'
        }
    }

    parameters {
        // 允许外部程序通过参数触发构建
        string(name: 'APP_NAME', defaultValue: 'iot-driver', description: '应用名称')
        string(name: 'APP_VERSION', defaultValue: '1.0.0', description: '应用版本')
        string(name: 'BUILD_CONTEXT', defaultValue: 'example_direct_upload', description: '构建上下文目录')
        choice(name: 'IMAGE_TAG_STRATEGY', choices: ['version-build', 'timestamp', 'latest'], description: '镜像标签策略')
        // 添加文件上传参数
        stashedFile(name: 'BUILD_ARCHIVE', description: '上传包含构建上下文的压缩文件 (支持 .zip, .tar, .tar.gz)')
    }

    environment {
        // Harbor 仓库配置
        HARBOR_REGISTRY = "registry.test.shifu.dev"
        HARBOR_PROJECT = "test-project"
        DOCKER_USER = "admin"
        DOCKER_PASS = 'harbor-credentials'  // Jenkins 凭据 ID
        
        // 镜像配置
        IMAGE_NAME = "${HARBOR_REGISTRY}/${HARBOR_PROJECT}/${params.APP_NAME}"
        IMAGE_TAG = generateImageTag()
        
        // 构建配置
        DOCKERFILE_PATH = "${params.BUILD_CONTEXT}/Dockerfile"
        BUILD_CONTEXT_PATH = "${params.BUILD_CONTEXT}"
    }

    stages {
        stage("清理工作空间") {
            steps {
                cleanWs()
            }
        }

        stage("处理上传文件") {
            steps {
                script {
                    echo "📦 开始处理上传的构建文件"
                    
                    // 获取上传文件的原始文件名
                    def originalFilename = env.BUILD_ARCHIVE_FILENAME
                    echo "上传文件名: ${originalFilename}"
                    
                    // 从 stash 中恢复上传的文件
                    unstash 'BUILD_ARCHIVE'
                    
                    // 重命名为原始文件名
                    sh """
                        if [ -n "\${BUILD_ARCHIVE_FILENAME}" ]; then
                            mv BUILD_ARCHIVE "\${BUILD_ARCHIVE_FILENAME}"
                            echo "✅ 文件已重命名为: \${BUILD_ARCHIVE_FILENAME}"
                        else
                            echo "⚠️  使用默认文件名: BUILD_ARCHIVE"
                        fi
                    """
                    
                    // 检测文件类型并解压
                    sh """
                        # 获取实际文件名
                        ARCHIVE_FILE="\${BUILD_ARCHIVE_FILENAME:-BUILD_ARCHIVE}"
                        
                        # 显示文件信息
                        echo "📋 文件信息:"
                        ls -lh "\$ARCHIVE_FILE"
                        file "\$ARCHIVE_FILE"
                        
                        # 根据文件扩展名解压
                        echo "📂 开始解压文件..."
                        if [[ "\$ARCHIVE_FILE" == *.zip ]]; then
                            echo "检测到 ZIP 文件，使用 unzip 解压"
                            unzip -q "\$ARCHIVE_FILE"
                        elif [[ "\$ARCHIVE_FILE" == *.tar.gz ]] || [[ "\$ARCHIVE_FILE" == *.tgz ]]; then
                            echo "检测到 TAR.GZ 文件，使用 tar 解压"
                            tar -xzf "\$ARCHIVE_FILE"
                        elif [[ "\$ARCHIVE_FILE" == *.tar ]]; then
                            echo "检测到 TAR 文件，使用 tar 解压"
                            tar -xf "\$ARCHIVE_FILE"
                        else
                            echo "❌ 不支持的文件格式: \$ARCHIVE_FILE"
                            echo "支持的格式: .zip, .tar, .tar.gz, .tgz"
                            exit 1
                        fi
                        
                        echo "✅ 文件解压完成"
                        echo "📁 工作空间内容:"
                        ls -la
                    """
                    
                    // 验证构建目录和文件是否存在
                    sh """
                        if [ ! -d "${BUILD_CONTEXT_PATH}" ]; then
                            echo "❌ 错误: 构建目录 ${BUILD_CONTEXT_PATH} 不存在"
                            echo "📁 当前目录内容:"
                            find . -type d -maxdepth 2
                            exit 1
                        fi
                        
                        if [ ! -f "${DOCKERFILE_PATH}" ]; then
                            echo "❌ 错误: Dockerfile ${DOCKERFILE_PATH} 不存在"
                            echo "📁 构建目录内容:"
                            ls -la ${BUILD_CONTEXT_PATH}/
                            exit 1
                        fi
                        
                        echo "✅ 构建文件验证通过"
                        echo "📁 构建目录内容:"
                        ls -la ${BUILD_CONTEXT_PATH}/
                    """
                }
            }
        }

        stage("构建准备") {
            steps {
                script {
                    echo "🔧 构建准备阶段"
                    echo "应用名称: ${params.APP_NAME}"
                    echo "应用版本: ${params.APP_VERSION}" 
                    echo "镜像名称: ${IMAGE_NAME}"
                    echo "镜像标签: ${IMAGE_TAG}"
                    echo "Harbor 仓库: ${HARBOR_REGISTRY}"
                    echo "项目: ${HARBOR_PROJECT}"
                    
                    // 显示构建信息
                    sh """
                        echo "=== 构建信息 ==="
                        echo "构建号: ${BUILD_NUMBER}"
                        echo "构建时间: \$(date)"
                        echo "构建节点: \$(hostname)"
                        echo "Jenkins URL: ${JENKINS_URL}"
                        echo "上传文件: \${BUILD_ARCHIVE_FILENAME:-BUILD_ARCHIVE}"
                    """
                }
            }
        }

        stage("使用 Kaniko 构建并推送镜像") {
            steps {
                container(name: 'kaniko', shell: '/busybox/sh') {
                    sh '''#!/busybox/sh
                        echo "🚀 开始使用 Kaniko 构建 Docker 镜像"
                        
                        # 显示 Kaniko 版本
                        /kaniko/executor version
                        
                        # 显示构建上下文
                        echo "📂 构建上下文内容:"
                        ls -la ${BUILD_CONTEXT_PATH}/
                        
                        # 执行镜像构建和推送
                        echo "🔨 开始构建镜像: ${IMAGE_NAME}:${IMAGE_TAG}"
                        
                        /kaniko/executor \\
                            --dockerfile=${DOCKERFILE_PATH} \\
                            --context=${BUILD_CONTEXT_PATH} \\
                            --destination=${IMAGE_NAME}:${IMAGE_TAG} \\
                            --destination=${IMAGE_NAME}:latest \\
                            --cache=true \\
                            --cache-ttl=24h \\
                            --cleanup
                        
                        echo "✅ 镜像构建并推送完成"
                        echo "📦 推送的镜像:"
                        echo "   - ${IMAGE_NAME}:${IMAGE_TAG}"
                        echo "   - ${IMAGE_NAME}:latest"
                    '''
                }
            }
        }

        stage("验证镜像推送") {
            steps {
                script {
                    echo "🔍 验证镜像是否成功推送到 Harbor"
                    
                    // 这里可以添加验证逻辑，比如调用 Harbor API 检查镜像是否存在
                    sh """
                        echo "镜像推送验证:"
                        echo "仓库地址: ${HARBOR_REGISTRY}"
                        echo "项目: ${HARBOR_PROJECT}"
                        echo "镜像: ${params.APP_NAME}:${IMAGE_TAG}"
                        
                        # 可以添加 Harbor API 调用来验证镜像
                        # curl -u admin:password ${HARBOR_REGISTRY}/api/v2.0/projects/${HARBOR_PROJECT}/repositories/${params.APP_NAME}/artifacts
                    """
                }
            }
        }
    }

    post {
        always {
            script {
                echo "🧹 清理构建环境"
            }
        }
        success {
            script {
                echo "🎉 构建成功!"
                echo "📦 镜像已推送到: ${IMAGE_NAME}:${IMAGE_TAG}"
                
                // 可以在这里添加成功通知，比如发送到企业微信、钉钉等
                // notifySuccess()
            }
        }
        failure {
            script {
                echo "❌ 构建失败!"
                
                // 可以在这里添加失败通知
                // notifyFailure()
            }
        }
    }
}

// 生成镜像标签的函数
def generateImageTag() {
    def strategy = params.IMAGE_TAG_STRATEGY ?: 'version-build'
    
    switch(strategy) {
        case 'version-build':
            return "${params.APP_VERSION}-${BUILD_NUMBER}"
        case 'timestamp':
            return "${params.APP_VERSION}-${new Date().format('yyyyMMdd-HHmmss')}"
        case 'latest':
            return 'latest'
        default:
            return "${params.APP_VERSION}-${BUILD_NUMBER}"
    }
} 