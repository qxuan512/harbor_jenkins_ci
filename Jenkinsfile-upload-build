pipeline {
    agent {
        kubernetes {
            yaml '''
kind: Pod
spec:
  containers:
  - name: kaniko
    image: gcr.io/kaniko-project/executor:debug
    imagePullPolicy: Always
    command:
    - sleep
    args:
    - 9999999
    volumeMounts:
      - name: jenkins-docker-cfg
        mountPath: /kaniko/.docker
    env:
    - name: DOCKER_CONFIG
      value: /kaniko/.docker
  volumes:
  - name: jenkins-docker-cfg
    projected:
      sources:
      - secret:
          name: harbor-credentials
          items:
            - key: .dockerconfigjson
              path: config.json
            '''
        }
    }

    parameters {
        // å…è®¸å¤–éƒ¨ç¨‹åºé€šè¿‡å‚æ•°è§¦å‘æ„å»º
        string(name: 'APP_NAME', defaultValue: 'iot-driver', description: 'åº”ç”¨åç§°')
        string(name: 'APP_VERSION', defaultValue: '1.0.0', description: 'åº”ç”¨ç‰ˆæœ¬')
        string(name: 'BUILD_CONTEXT', defaultValue: 'example_direct_upload', description: 'æ„å»ºä¸Šä¸‹æ–‡ç›®å½•')
        choice(name: 'IMAGE_TAG_STRATEGY', choices: ['version-build', 'timestamp', 'latest'], description: 'é•œåƒæ ‡ç­¾ç­–ç•¥')
        // æ„å»ºå¹³å°å‚æ•°
        choice(name: 'BUILD_PLATFORM', 
               choices: ['linux/amd64', 'linux/arm64'], 
               description: 'æ„å»ºå¹³å°é€‰æ‹©')
        // å”¯ä¸€IDå‚æ•°ï¼Œç¡®ä¿æ¯ä¸ªæ„å»ºjobçš„å”¯ä¸€æ€§
        string(name: 'BUILD_UNIQUE_ID', defaultValue: '', description: 'æ„å»ºå”¯ä¸€æ ‡è¯†ç¬¦ (å¯é€‰ï¼Œç”¨äºç¡®ä¿æ„å»ºçš„å”¯ä¸€æ€§ï¼Œç•™ç©ºåˆ™è‡ªåŠ¨ç”Ÿæˆ)')
        // æ·»åŠ æ–‡ä»¶ä¸Šä¼ å‚æ•°
        stashedFile(name: 'BUILD_ARCHIVE', description: 'ä¸Šä¼ åŒ…å«æ„å»ºä¸Šä¸‹æ–‡çš„å‹ç¼©æ–‡ä»¶ (æ”¯æŒ .zip, .tar, .tar.gz)')
    }

    environment {
        // Harbor ä»“åº“é…ç½®
        HARBOR_REGISTRY = "registry.test.shifu.dev"
        HARBOR_PROJECT = "test-project"
        DOCKER_USER = "admin"
        DOCKER_PASS = 'harbor-credentials'  // Jenkins å‡­æ® ID
        
        // é•œåƒé…ç½®
        IMAGE_NAME = "${HARBOR_REGISTRY}/${HARBOR_PROJECT}/${params.APP_NAME}"
        IMAGE_TAG = generateImageTag()
        
        // æ„å»ºé…ç½®
        DOCKERFILE_PATH = "${params.BUILD_CONTEXT}/Dockerfile"
        BUILD_CONTEXT_PATH = "${params.BUILD_CONTEXT}"
        
        // å¹³å°é…ç½®
        BUILD_PLATFORM = "${params.BUILD_PLATFORM}"
    }

    stages {
        stage("æ¸…ç†å·¥ä½œç©ºé—´") {
            steps {
                cleanWs()
            }
        }

        stage("å¤„ç†ä¸Šä¼ æ–‡ä»¶") {
            steps {
                script {
                    echo "ğŸ“¦ å¼€å§‹å¤„ç†ä¸Šä¼ çš„æ„å»ºæ–‡ä»¶"
                    
                    // è·å–ä¸Šä¼ æ–‡ä»¶çš„åŸå§‹æ–‡ä»¶å
                    def originalFilename = env.BUILD_ARCHIVE_FILENAME
                    echo "ä¸Šä¼ æ–‡ä»¶å: ${originalFilename}"
                    
                    // ä» stash ä¸­æ¢å¤ä¸Šä¼ çš„æ–‡ä»¶
                    unstash 'BUILD_ARCHIVE'
                    
                    // æ£€æŸ¥æ–‡ä»¶å¹¶ç¡®å®šå®é™…æ–‡ä»¶å
                    sh """
                        echo "ğŸ“‹ æ£€æŸ¥ä¸Šä¼ æ–‡ä»¶ä¿¡æ¯..."
                        ls -la BUILD_ARCHIVE* || true
                        
                        # æ£€æŸ¥æ˜¯å¦æœ‰åŸå§‹æ–‡ä»¶å
                        if [ -n "\${BUILD_ARCHIVE_FILENAME}" ] && [ "\${BUILD_ARCHIVE_FILENAME}" != "null" ]; then
                            echo "âœ… ä½¿ç”¨åŸå§‹æ–‡ä»¶å: \${BUILD_ARCHIVE_FILENAME}"
                            if [ -f "BUILD_ARCHIVE" ]; then
                                mv BUILD_ARCHIVE "\${BUILD_ARCHIVE_FILENAME}"
                            fi
                            ARCHIVE_FILE="\${BUILD_ARCHIVE_FILENAME}"
                        else
                            echo "âš ï¸  æ–‡ä»¶åä¸ºç©ºæˆ–nullï¼Œå°è¯•æ£€æµ‹æ–‡ä»¶ç±»å‹"
                            # ä½¿ç”¨ file å‘½ä»¤æ£€æµ‹æ–‡ä»¶ç±»å‹
                            FILE_TYPE=\$(file BUILD_ARCHIVE 2>/dev/null || echo "unknown")
                            echo "æ–‡ä»¶ç±»å‹æ£€æµ‹: \$FILE_TYPE"
                            
                            if echo "\$FILE_TYPE" | grep -q "Zip archive"; then
                                ARCHIVE_FILE="BUILD_ARCHIVE.zip"
                                mv BUILD_ARCHIVE "\$ARCHIVE_FILE"
                                echo "âœ… æ£€æµ‹ä¸ºZIPæ–‡ä»¶ï¼Œé‡å‘½åä¸º: \$ARCHIVE_FILE"
                            elif echo "\$FILE_TYPE" | grep -q "gzip compressed"; then
                                ARCHIVE_FILE="BUILD_ARCHIVE.tar.gz"
                                mv BUILD_ARCHIVE "\$ARCHIVE_FILE"
                                echo "âœ… æ£€æµ‹ä¸ºTAR.GZæ–‡ä»¶ï¼Œé‡å‘½åä¸º: \$ARCHIVE_FILE"
                            elif echo "\$FILE_TYPE" | grep -q "POSIX tar archive"; then
                                ARCHIVE_FILE="BUILD_ARCHIVE.tar"
                                mv BUILD_ARCHIVE "\$ARCHIVE_FILE"
                                echo "âœ… æ£€æµ‹ä¸ºTARæ–‡ä»¶ï¼Œé‡å‘½åä¸º: \$ARCHIVE_FILE"
                            else
                                ARCHIVE_FILE="BUILD_ARCHIVE"
                                echo "âš ï¸  æ— æ³•è¯†åˆ«æ–‡ä»¶ç±»å‹ï¼Œä½¿ç”¨é»˜è®¤åç§°: \$ARCHIVE_FILE"
                            fi
                        fi
                        
                        echo "æœ€ç»ˆä½¿ç”¨çš„æ–‡ä»¶å: \$ARCHIVE_FILE"
                        echo "ARCHIVE_FILE=\$ARCHIVE_FILE" > archive_info.env
                    """
                    
                    // è¯»å–æ–‡ä»¶åä¿¡æ¯
                    def archiveInfo = readFile('archive_info.env').trim()
                    def archiveFile = archiveInfo.split('=')[1]
                    env.ACTUAL_ARCHIVE_FILE = archiveFile
                    
                    echo "ç¡®å®šçš„å½’æ¡£æ–‡ä»¶: ${env.ACTUAL_ARCHIVE_FILE}"
                    
                    // æ£€æµ‹æ–‡ä»¶ç±»å‹å¹¶è§£å‹ - ä½¿ç”¨ Pipeline Utility Steps
                    script {
                        def uploadedArchive = env.ACTUAL_ARCHIVE_FILE
                        
                        echo "ğŸ“‹ æ–‡ä»¶ä¿¡æ¯:"
                        sh "ls -lh '${uploadedArchive}'"
                        
                        echo "ğŸ“‚ å¼€å§‹è§£å‹æ–‡ä»¶: ${uploadedArchive}"
                        
                        // æ ¹æ®æ–‡ä»¶æ‰©å±•åä½¿ç”¨é€‚å½“çš„ Pipeline Utility Steps
                        try {
                            if (uploadedArchive.endsWith('.zip')) {
                                echo "ä½¿ç”¨ Pipeline Utility Steps unzip è§£å‹ ZIP æ–‡ä»¶"
                                unzip zipFile: uploadedArchive, quiet: false
                                echo "âœ… ZIP æ–‡ä»¶è§£å‹å®Œæˆ"
                            } else if (uploadedArchive.endsWith('.tar.gz') || uploadedArchive.endsWith('.tgz')) {
                                echo "ä½¿ç”¨ Pipeline Utility Steps untar è§£å‹ TAR.GZ æ–‡ä»¶"
                                untar file: uploadedArchive, compression: 'gzip', quiet: false
                                echo "âœ… TAR.GZ æ–‡ä»¶è§£å‹å®Œæˆ"
                            } else if (uploadedArchive.endsWith('.tar')) {
                                echo "ä½¿ç”¨ Pipeline Utility Steps untar è§£å‹ TAR æ–‡ä»¶"
                                untar file: uploadedArchive, quiet: false
                                echo "âœ… TAR æ–‡ä»¶è§£å‹å®Œæˆ"
                            } else {
                                echo "âš ï¸  æœªçŸ¥æ–‡ä»¶æ ¼å¼ï¼Œå°è¯•é€šç”¨è§£å‹æ–¹æ³•"
                                // å…ˆå°è¯•ä½œä¸º ZIP æ–‡ä»¶
                                try {
                                    echo "å°è¯•æŒ‰ ZIP æ ¼å¼è§£å‹"
                                    unzip zipFile: uploadedArchive, quiet: false
                                    echo "âœ… æŒ‰ ZIP æ ¼å¼è§£å‹æˆåŠŸ"
                                } catch (Exception zipEx) {
                                    echo "ZIP è§£å‹å¤±è´¥ï¼Œå°è¯•æŒ‰ TAR æ ¼å¼è§£å‹"
                                    try {
                                        untar file: uploadedArchive, quiet: false
                                        echo "âœ… æŒ‰ TAR æ ¼å¼è§£å‹æˆåŠŸ"
                                    } catch (Exception tarEx) {
                                        echo "TAR è§£å‹å¤±è´¥ï¼Œå°è¯•æŒ‰ TAR.GZ æ ¼å¼è§£å‹"
                                        untar file: uploadedArchive, compression: 'gzip', quiet: false
                                        echo "âœ… æŒ‰ TAR.GZ æ ¼å¼è§£å‹æˆåŠŸ"
                                    }
                                }
                            }
                        } catch (Exception e) {
                            echo "âŒ Pipeline Utility Steps è§£å‹å¤±è´¥: ${e.getMessage()}"
                            echo "å›é€€åˆ°ä¼ ç»Ÿæ–¹æ³•è§£å‹..."
                            
                            // å›é€€åˆ°ä¼ ç»Ÿå‘½ä»¤è¡Œè§£å‹
                            if (uploadedArchive.endsWith('.zip')) {
                                echo "ä½¿ç”¨ Python è§£å‹ ZIP æ–‡ä»¶"
                                sh '''
                                    python3 -c "
import zipfile
import sys
try:
    with zipfile.ZipFile('${uploadedArchive}', 'r') as zip_ref:
        zip_ref.extractall('.')
    print('âœ… Python ZIP è§£å‹æˆåŠŸ')
except Exception as e:
    print(f'âŒ Python ZIP è§£å‹å¤±è´¥: {e}')
    sys.exit(1)
                                    "
                                '''
                            } else if (uploadedArchive.endsWith('.tar.gz') || uploadedArchive.endsWith('.tgz')) {
                                echo "ä½¿ç”¨ tar è§£å‹ TAR.GZ æ–‡ä»¶"
                                sh "tar -xzf '${uploadedArchive}'"
                            } else if (uploadedArchive.endsWith('.tar')) {
                                echo "ä½¿ç”¨ tar è§£å‹ TAR æ–‡ä»¶"
                                sh "tar -xf '${uploadedArchive}'"
                            }
                        }
                        
                        echo "ğŸ“ è§£å‹åå·¥ä½œç©ºé—´å†…å®¹:"
                        sh "ls -la"
                    }
                    
                    // éªŒè¯æ„å»ºç›®å½•å’Œæ–‡ä»¶æ˜¯å¦å­˜åœ¨
                    sh """
                        if [ ! -d "${BUILD_CONTEXT_PATH}" ]; then
                            echo "âŒ é”™è¯¯: æ„å»ºç›®å½• ${BUILD_CONTEXT_PATH} ä¸å­˜åœ¨"
                            echo "ğŸ“ å½“å‰ç›®å½•å†…å®¹:"
                            find . -type d -maxdepth 2
                            exit 1
                        fi
                        
                        if [ ! -f "${DOCKERFILE_PATH}" ]; then
                            echo "âŒ é”™è¯¯: Dockerfile ${DOCKERFILE_PATH} ä¸å­˜åœ¨"
                            echo "ğŸ“ æ„å»ºç›®å½•å†…å®¹:"
                            ls -la ${BUILD_CONTEXT_PATH}/
                            exit 1
                        fi
                        
                        echo "âœ… æ„å»ºæ–‡ä»¶éªŒè¯é€šè¿‡"
                        echo "ğŸ“ æ„å»ºç›®å½•å†…å®¹:"
                        ls -la ${BUILD_CONTEXT_PATH}/
                    """
                }
            }
        }

        stage("æ„å»ºå‡†å¤‡") {
            steps {
                script {
                    echo "ğŸ”§ æ„å»ºå‡†å¤‡é˜¶æ®µ"
                    
                    // å¤„ç†å”¯ä¸€ID - é€šå¸¸ç”±Pythonè„šæœ¬ç”Ÿæˆå¹¶ä¼ é€’
                    def uniqueId = params.BUILD_UNIQUE_ID
                    if (!uniqueId || uniqueId.trim().isEmpty()) {
                        uniqueId = "${new Date().format('yyyyMMddHHmmss')}-${BUILD_NUMBER}-${UUID.randomUUID().toString().substring(0, 8)}"
                        echo "ğŸ“‹ Jenkinsç”Ÿæˆå”¯ä¸€ID: ${uniqueId}"
                    } else {
                        echo "ğŸ“‹ ä½¿ç”¨ä¼ é€’çš„å”¯ä¸€ID: ${uniqueId}"
                    }
                    env.ACTUAL_UNIQUE_ID = uniqueId
                    
                    // å¤„ç†å¹³å°é…ç½®
                    def platform = params.BUILD_PLATFORM
                    
                    echo "ğŸ—ï¸  æ„å»ºå¹³å°é…ç½®:"
                    echo "   é€‰æ‹©çš„å¹³å°: ${platform}"
                    
                    echo "ğŸ“‹ æ„å»ºé…ç½®ä¿¡æ¯:"
                    echo "   åº”ç”¨åç§°: ${params.APP_NAME}"
                    echo "   åº”ç”¨ç‰ˆæœ¬: ${params.APP_VERSION}" 
                    echo "   æ„å»ºå”¯ä¸€ID: ${uniqueId}"
                    echo "   é•œåƒåç§°: ${IMAGE_NAME}"
                    echo "   é•œåƒæ ‡ç­¾: ${IMAGE_TAG}"
                    echo "   Harbor ä»“åº“: ${HARBOR_REGISTRY}"
                    echo "   é¡¹ç›®: ${HARBOR_PROJECT}"
                    echo "   æ„å»ºå¹³å°: ${platform}"
                    
                    // æ˜¾ç¤ºæ„å»ºä¿¡æ¯
                    sh """
                        echo "=== æ„å»ºä¿¡æ¯ ==="
                        echo "æ„å»ºå·: ${BUILD_NUMBER}"
                        echo "æ„å»ºå”¯ä¸€ID: ${uniqueId}"
                        echo "æ„å»ºæ—¶é—´: \$(date)"
                        echo "æ„å»ºèŠ‚ç‚¹: \$(hostname)"
                        echo "Jenkins URL: ${JENKINS_URL}"
                        echo "åŸå§‹æ–‡ä»¶å: \${BUILD_ARCHIVE_FILENAME:-'æœªè®¾ç½®'}"
                        echo "å®é™…ä½¿ç”¨æ–‡ä»¶: ${env.ACTUAL_ARCHIVE_FILE}"
                        echo "æ„å»ºå¹³å°: ${platform}"
                    """
                }
            }
        }

        stage("ä½¿ç”¨ Kaniko æ„å»ºå¹¶æ¨é€é•œåƒ") {
            steps {
                container(name: 'kaniko', shell: '/busybox/sh') {
                    script {
                        echo "ğŸš€ å¼€å§‹é•œåƒæ„å»º"
                        
                        sh '''#!/busybox/sh
                            echo "ğŸ—ï¸  æ„å»ºé…ç½®"
                            echo "æ„å»ºå¹³å°: ${BUILD_PLATFORM}"
                            
                            # æå–å¹³å°æ¶æ„åç§°ï¼ˆå»æ‰ linux/ å‰ç¼€ï¼‰
                            PLATFORM_ARCH=$(echo "${BUILD_PLATFORM}" | sed 's/linux\\///')
                            echo "å¹³å°æ¶æ„: ${PLATFORM_ARCH}"
                            
                            # æ˜¾ç¤º Kaniko ç‰ˆæœ¬
                            /kaniko/executor version
                            
                            # æ˜¾ç¤ºæ„å»ºä¸Šä¸‹æ–‡
                            echo "ğŸ“‚ æ„å»ºä¸Šä¸‹æ–‡å†…å®¹:"
                            ls -la ${BUILD_CONTEXT_PATH}/
                            
                            # æ˜¾ç¤ºæ„å»ºä¸Šä¸‹æ–‡å¤§å°
                            echo "ğŸ“ æ„å»ºä¸Šä¸‹æ–‡å¤§å°:"
                            du -sh ${BUILD_CONTEXT_PATH}/
                            
                            # æ‰§è¡Œé•œåƒæ„å»ºï¼ˆä¸æ¨é€ï¼Œå…ˆè·å–å¤§å°ä¿¡æ¯ï¼‰
                            echo "ğŸ”¨ å¼€å§‹æ„å»ºé•œåƒ: ${IMAGE_NAME}:${IMAGE_TAG}-${PLATFORM_ARCH}"
                            echo "ç›®æ ‡å¹³å°: ${BUILD_PLATFORM}"
                            
                            # è®°å½•æ„å»ºå¼€å§‹æ—¶é—´
                            BUILD_START_TIME=$(date +%s)
                            echo "â±ï¸  æ„å»ºå¼€å§‹æ—¶é—´: $(date)"
                            
                            # ä½¿ç”¨ --no-push å…ˆæ„å»ºé•œåƒä½†ä¸æ¨é€ï¼Œä»¥ä¾¿è·å–å¤§å°ä¿¡æ¯
                            echo "ğŸ”¨ ç¬¬ä¸€é˜¶æ®µï¼šæ„å»ºé•œåƒï¼ˆä¸æ¨é€ï¼‰"
                            /kaniko/executor \\
                                --dockerfile=${DOCKERFILE_PATH} \\
                                --context=${BUILD_CONTEXT_PATH} \\
                                --no-push \\
                                --tar-path=/tmp/image.tar \\
                                --custom-platform=${BUILD_PLATFORM} \\
                                --build-arg=TARGETARCH=${PLATFORM_ARCH} \\
                                --cache=true \\
                                --cache-ttl=24h \\
                                --verbosity=info
                            
                            # è®°å½•æ„å»ºç»“æŸæ—¶é—´
                            BUILD_END_TIME=$(date +%s)
                            BUILD_DURATION=$((BUILD_END_TIME - BUILD_START_TIME))
                            echo "â±ï¸  æ„å»ºå®Œæˆæ—¶é—´: $(date)"
                            echo "â±ï¸  æ„å»ºè€—æ—¶: ${BUILD_DURATION} ç§’"
                            
                            # æ£€æŸ¥æ„å»ºäº§ç”Ÿçš„ tar æ–‡ä»¶å¤§å°
                            echo ""
                            echo "ğŸ“¦ ==========================="
                            echo "ğŸ“¦ é•œåƒæ„å»ºå®Œæˆ - å¤§å°ä¿¡æ¯"
                            echo "ğŸ“¦ ==========================="
                            
                            if [ -f /tmp/image.tar ]; then
                                TAR_SIZE_BYTES=$(stat -c%s /tmp/image.tar 2>/dev/null || wc -c < /tmp/image.tar)
                                TAR_SIZE_MB=$((TAR_SIZE_BYTES / 1024 / 1024))
                                TAR_SIZE_HUMAN=$(du -h /tmp/image.tar | cut -f1)
                                
                                echo "ğŸ“ é•œåƒ TAR æ–‡ä»¶å¤§å°:"
                                echo "   ğŸ“Š åŸå§‹å¤§å°: ${TAR_SIZE_BYTES} bytes"
                                echo "   ğŸ“Š äººç±»å¯è¯»: ${TAR_SIZE_HUMAN}"
                                echo "   ğŸ“Š å¤§çº¦: ${TAR_SIZE_MB} MB"
                                
                                # æ£€æŸ¥ tar æ–‡ä»¶å†…å®¹ä»¥è·å–æ›´å¤šä¿¡æ¯
                                echo ""
                                echo "ğŸ“‹ é•œåƒå†…å®¹åˆ†æ:"
                                tar -tvf /tmp/image.tar | head -20 | while read line; do
                                    echo "   $line"
                                done
                                
                                # ç»Ÿè®¡å±‚æ•°
                                LAYER_COUNT=$(tar -tf /tmp/image.tar | grep "layer.tar" | wc -l)
                                echo "   ğŸ“Š é•œåƒå±‚æ•°: ${LAYER_COUNT}"
                                
                            else
                                echo "âš ï¸  æœªæ‰¾åˆ°é•œåƒ TAR æ–‡ä»¶ï¼Œå¯èƒ½æ„å»ºå¤±è´¥"
                                ls -la /tmp/
                            fi
                            
                            echo "ğŸ“¦ ==========================="
                            echo ""
                            
                            # ç¬¬äºŒé˜¶æ®µï¼šæ¨é€é•œåƒ
                            echo "ğŸš€ ç¬¬äºŒé˜¶æ®µï¼šæ¨é€é•œåƒåˆ°ä»“åº“"
                            echo "ğŸ“¤ æ¨é€å‰é•œåƒä¿¡æ¯å·²æ˜¾ç¤ºï¼Œå¼€å§‹æ¨é€..."
                            
                            PUSH_START_TIME=$(date +%s)
                            echo "â±ï¸  æ¨é€å¼€å§‹æ—¶é—´: $(date)"
                            
                            /kaniko/executor \\
                                --dockerfile=${DOCKERFILE_PATH} \\
                                --context=${BUILD_CONTEXT_PATH} \\
                                --destination=${IMAGE_NAME}:${IMAGE_TAG}-${PLATFORM_ARCH} \\
                                --destination=${IMAGE_NAME}:latest-${PLATFORM_ARCH} \\
                                --custom-platform=${BUILD_PLATFORM} \\
                                --build-arg=TARGETARCH=${PLATFORM_ARCH} \\
                                --cache=true \\
                                --cache-ttl=24h \\
                                --cleanup \\
                                --verbosity=info
                            
                            PUSH_END_TIME=$(date +%s)
                            PUSH_DURATION=$((PUSH_END_TIME - PUSH_START_TIME))
                            echo "â±ï¸  æ¨é€å®Œæˆæ—¶é—´: $(date)"
                            echo "â±ï¸  æ¨é€è€—æ—¶: ${PUSH_DURATION} ç§’"
                            
                            TOTAL_DURATION=$((PUSH_END_TIME - BUILD_START_TIME))
                            echo "â±ï¸  æ€»è€—æ—¶: ${TOTAL_DURATION} ç§’"
                            
                            echo ""
                            echo "âœ… ================================="
                            echo "âœ… é•œåƒæ„å»ºå¹¶æ¨é€å®Œæˆ"
                            echo "âœ… ================================="
                            echo "ğŸ“¦ æ¨é€çš„é•œåƒ:"
                            echo "   - ${IMAGE_NAME}:${IMAGE_TAG}-${PLATFORM_ARCH} (${BUILD_PLATFORM})"
                            echo "   - ${IMAGE_NAME}:latest-${PLATFORM_ARCH} (${BUILD_PLATFORM})"
                            if [ -n "${TAR_SIZE_HUMAN:-}" ]; then
                                echo "ğŸ“ é•œåƒå¤§å°: ${TAR_SIZE_HUMAN} (çº¦ ${TAR_SIZE_MB} MB)"
                            fi
                            echo "â±ï¸  æ„å»º+æ¨é€æ€»è€—æ—¶: ${TOTAL_DURATION} ç§’"
                            echo "âœ… ================================="
                        '''
                    }
                }
            }
        }

        stage("éªŒè¯é•œåƒæ¨é€") {
            steps {
                script {
                    echo "ğŸ” éªŒè¯é•œåƒæ˜¯å¦æˆåŠŸæ¨é€åˆ° Harbor"
                    
                    def platform = params.BUILD_PLATFORM
                    
                    echo "ğŸ“‹ é•œåƒæ¨é€éªŒè¯:"
                    sh """
                        # æå–å¹³å°æ¶æ„åç§°
                        PLATFORM_ARCH=\$(echo "${platform}" | sed 's/linux\\///')
                        
                        echo "ä»“åº“åœ°å€: ${HARBOR_REGISTRY}"
                        echo "é¡¹ç›®: ${HARBOR_PROJECT}"
                        echo "é•œåƒ: ${params.APP_NAME}:${IMAGE_TAG}-\${PLATFORM_ARCH}"
                        echo "å¹³å°: ${platform}"
                        
                        echo "æ¨é€çš„é•œåƒ:"
                        echo "  ğŸ“¦ ${IMAGE_NAME}:${IMAGE_TAG}-\${PLATFORM_ARCH} (${platform})"
                        echo "  ğŸ“¦ ${IMAGE_NAME}:latest-\${PLATFORM_ARCH} (${platform})"
                        
                        echo ""
                        echo "ğŸ” ==============================="
                        echo "ğŸ” æŸ¥è¯¢Harborä¸­çš„é•œåƒè¯¦ç»†ä¿¡æ¯"
                        echo "ğŸ” ==============================="
                        
                        # å°è¯•é€šè¿‡Harbor APIæŸ¥è¯¢é•œåƒä¿¡æ¯
                        # æ³¨æ„ï¼šè¿™éœ€è¦Harbor API v2.0æ”¯æŒï¼Œå¦‚æœå¤±è´¥ä¼šä¼˜é›…å¤„ç†
                        echo "ğŸ“¡ å°è¯•æŸ¥è¯¢Harbor APIè·å–é•œåƒè¯¦ç»†ä¿¡æ¯..."
                        
                        # æ„å»ºAPI URL
                        REPO_NAME="${params.APP_NAME}"
                        TAG_NAME="${IMAGE_TAG}-\${PLATFORM_ARCH}"
                        API_URL="https://${HARBOR_REGISTRY}/api/v2.0/projects/${HARBOR_PROJECT}/repositories/\${REPO_NAME}/artifacts/\${TAG_NAME}"
                        
                        echo "API URL: \${API_URL}"
                        
                        # å°è¯•æŸ¥è¯¢é•œåƒä¿¡æ¯ï¼ˆå¦‚æœå¤±è´¥ä¸å½±å“æ„å»ºï¼‰
                        if command -v curl >/dev/null 2>&1; then
                            echo "ä½¿ç”¨curlæŸ¥è¯¢é•œåƒä¿¡æ¯..."
                            
                            # å°è¯•ä¸å¸¦è®¤è¯çš„æŸ¥è¯¢ï¼ˆå…¬å¼€é¡¹ç›®ï¼‰
                            RESPONSE=\$(curl -s -w "HTTPSTATUS:%{http_code}" "\${API_URL}" 2>/dev/null || echo "HTTPSTATUS:000")
                            HTTP_STATUS=\$(echo "\$RESPONSE" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                            BODY=\$(echo "\$RESPONSE" | sed 's/HTTPSTATUS:[0-9]*\$//')
                            
                            echo "HTTPçŠ¶æ€ç : \${HTTP_STATUS}"
                            
                            if [ "\${HTTP_STATUS}" = "200" ] && [ -n "\${BODY}" ]; then
                                echo "âœ… æˆåŠŸè·å–é•œåƒä¿¡æ¯:"
                                
                                # å°è¯•è§£æJSONå“åº”è·å–å¤§å°ä¿¡æ¯
                                if command -v python3 >/dev/null 2>&1; then
                                    echo "\${BODY}" | python3 -c "
import json
import sys
try:
    data = json.load(sys.stdin)
    if 'size' in data:
        size_bytes = data['size']
        size_mb = size_bytes / (1024 * 1024)
        size_gb = size_mb / 1024
        print(f'ğŸ“ Harborä¸­é•œåƒå¤§å°:')
        print(f'   ğŸ“Š å­—èŠ‚: {size_bytes:,} bytes')
        print(f'   ğŸ“Š MB: {size_mb:.2f} MB')
        if size_gb >= 1:
            print(f'   ğŸ“Š GB: {size_gb:.2f} GB')
        
        if 'push_time' in data:
            print(f'   â° æ¨é€æ—¶é—´: {data[\"push_time\"]}')
        
        if 'digest' in data:
            print(f'   ğŸ” æ‘˜è¦: {data[\"digest\"][:32]}...')
            
        if 'labels' in data and data['labels']:
            print(f'   ğŸ·ï¸  æ ‡ç­¾æ•°é‡: {len(data[\"labels\"])}')
            
    else:
        print('âš ï¸  å“åº”ä¸­æœªæ‰¾åˆ°å¤§å°ä¿¡æ¯')
        print('åŸå§‹å“åº”:')
        print(json.dumps(data, indent=2)[:500] + '...' if len(json.dumps(data)) > 500 else json.dumps(data, indent=2))
        
except Exception as e:
    print(f'âŒ JSONè§£æå¤±è´¥: {e}')
    print('åŸå§‹å“åº”:')
    print(sys.stdin.read()[:500] + '...')
                                    " 2>/dev/null || echo "Python JSONè§£æå¤±è´¥ï¼Œæ˜¾ç¤ºåŸå§‹å“åº”å‰500å­—ç¬¦: \${BODY:0:500}"
                                else
                                    echo "åŸå§‹APIå“åº”: \${BODY:0:200}..."
                                fi
                                
                            elif [ "\${HTTP_STATUS}" = "401" ] || [ "\${HTTP_STATUS}" = "403" ]; then
                                echo "âš ï¸  éœ€è¦è®¤è¯æˆ–æƒé™ä¸è¶³ (çŠ¶æ€ç : \${HTTP_STATUS})"
                                echo "é•œåƒå¯èƒ½åœ¨ç§æœ‰é¡¹ç›®ä¸­ï¼Œæ— æ³•é€šè¿‡APIè·å–è¯¦ç»†ä¿¡æ¯"
                                
                            elif [ "\${HTTP_STATUS}" = "404" ]; then
                                echo "âŒ é•œåƒæœªæ‰¾åˆ° (çŠ¶æ€ç : 404)"
                                echo "å¯èƒ½é•œåƒæ¨é€å¤±è´¥æˆ–æ ‡ç­¾ä¸æ­£ç¡®"
                                
                            else
                                echo "âš ï¸  APIæŸ¥è¯¢å¤±è´¥ (çŠ¶æ€ç : \${HTTP_STATUS})"
                                if [ -n "\${BODY}" ]; then
                                    echo "å“åº”: \${BODY:0:200}..."
                                fi
                            fi
                        else
                            echo "âš ï¸  curlå‘½ä»¤ä¸å¯ç”¨ï¼Œè·³è¿‡APIæŸ¥è¯¢"
                        fi
                        
                        # ä¹Ÿå°è¯•æŸ¥è¯¢latestæ ‡ç­¾çš„ä¿¡æ¯
                        echo ""
                        echo "ğŸ“¡ æŸ¥è¯¢latestæ ‡ç­¾ä¿¡æ¯..."
                        LATEST_API_URL="https://${HARBOR_REGISTRY}/api/v2.0/projects/${HARBOR_PROJECT}/repositories/\${REPO_NAME}/artifacts/latest-\${PLATFORM_ARCH}"
                        
                        if command -v curl >/dev/null 2>&1; then
                            LATEST_RESPONSE=\$(curl -s -w "HTTPSTATUS:%{http_code}" "\${LATEST_API_URL}" 2>/dev/null || echo "HTTPSTATUS:000")
                            LATEST_HTTP_STATUS=\$(echo "\$LATEST_RESPONSE" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
                            
                            if [ "\${LATEST_HTTP_STATUS}" = "200" ]; then
                                echo "âœ… latest-\${PLATFORM_ARCH} æ ‡ç­¾ä¹Ÿå·²æˆåŠŸæ¨é€"
                            else
                                echo "âš ï¸  latest-\${PLATFORM_ARCH} æ ‡ç­¾çŠ¶æ€: \${LATEST_HTTP_STATUS}"
                            fi
                        fi
                        
                        echo "ğŸ” ==============================="
                    """
                }
            }
        }
    }

    post {
        always {
            script {
                echo "ğŸ§¹ æ¸…ç†æ„å»ºç¯å¢ƒ"
            }
        }
        success {
            script {
                def platform = params.BUILD_PLATFORM
                def platformArch = platform.replace('linux/', '')
                
                echo "ğŸ‰ æ„å»ºæˆåŠŸ!"
                echo "ğŸ“¦ é•œåƒå·²æ¨é€åˆ°: ${IMAGE_NAME}:${IMAGE_TAG}-${platformArch}"
                echo "ğŸ“¦ Latest é•œåƒ: ${IMAGE_NAME}:latest-${platformArch}"
                
                // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æˆåŠŸé€šçŸ¥ï¼Œæ¯”å¦‚å‘é€åˆ°ä¼ä¸šå¾®ä¿¡ã€é’‰é’‰ç­‰
                // notifySuccess()
            }
        }
        failure {
            script {
                echo "âŒ æ„å»ºå¤±è´¥!"
                
                // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ å¤±è´¥é€šçŸ¥
                // notifyFailure()
            }
        }
    }
}

// ç”Ÿæˆé•œåƒæ ‡ç­¾çš„å‡½æ•°
def generateImageTag() {
    def strategy = params.IMAGE_TAG_STRATEGY ?: 'version-build'
    
    switch(strategy) {
        case 'version-build':
            return "${params.APP_VERSION}"
        case 'timestamp':
            return "${params.APP_VERSION}-${new Date().format('yyyyMMdd-HHmmss')}"
        case 'latest':
            return 'latest'
        default:
            return "${params.APP_VERSION}"
    }
} 