pipeline {
    agent {
        kubernetes {
            yaml '''
kind: Pod
spec:
  containers:
  - name: kaniko
    image: gcr.io/kaniko-project/executor:debug
    imagePullPolicy: Always
    command:
    - sleep
    args:
    - 9999999
    volumeMounts:
      - name: jenkins-docker-cfg
        mountPath: /kaniko/.docker
    env:
    - name: DOCKER_CONFIG
      value: /kaniko/.docker
  volumes:
  - name: jenkins-docker-cfg
    projected:
      sources:
      - secret:
          name: harbor-credentials
          items:
            - key: .dockerconfigjson
              path: config.json
            '''
        }
    }

    parameters {
        // ÂÖÅËÆ∏Â§ñÈÉ®Á®ãÂ∫èÈÄöËøáÂèÇÊï∞Ëß¶ÂèëÊûÑÂª∫
        string(name: 'APP_NAME', defaultValue: 'iot-driver', description: 'Â∫îÁî®ÂêçÁß∞')
        string(name: 'APP_VERSION', defaultValue: '1.0.0', description: 'Â∫îÁî®ÁâàÊú¨')
        string(name: 'BUILD_CONTEXT', defaultValue: 'example_direct_upload', description: 'ÊûÑÂª∫‰∏ä‰∏ãÊñáÁõÆÂΩï')
        choice(name: 'IMAGE_TAG_STRATEGY', choices: ['version-build', 'timestamp', 'latest'], description: 'ÈïúÂÉèÊ†áÁ≠æÁ≠ñÁï•')
        // ÊûÑÂª∫Âπ≥Âè∞ÂèÇÊï∞ - ÊîØÊåÅÂ§öÂπ≥Âè∞ÊûÑÂª∫
        choice(name: 'BUILD_PLATFORMS', 
               choices: ['linux/amd64', 'linux/arm64', 'linux/amd64,linux/arm64'], 
               description: 'ÊûÑÂª∫Âπ≥Âè∞ÈÄâÊã© (ÊîØÊåÅÂ§öÂπ≥Âè∞Âπ∂Ë°åÊûÑÂª∫)')
        // ÂîØ‰∏ÄIDÂèÇÊï∞ÔºåÁ°Æ‰øùÊØè‰∏™ÊûÑÂª∫jobÁöÑÂîØ‰∏ÄÊÄß
        string(name: 'BUILD_UNIQUE_ID', defaultValue: '', description: 'ÊûÑÂª∫ÂîØ‰∏ÄÊ†áËØÜÁ¨¶ (ÂèØÈÄâÔºåÁî®‰∫éÁ°Æ‰øùÊûÑÂª∫ÁöÑÂîØ‰∏ÄÊÄßÔºåÁïôÁ©∫ÂàôËá™Âä®ÁîüÊàê)')
        // Ê∑ªÂä†Êñá‰ª∂‰∏ä‰º†ÂèÇÊï∞
        stashedFile(name: 'BUILD_ARCHIVE', description: '‰∏ä‰º†ÂåÖÂê´ÊûÑÂª∫‰∏ä‰∏ãÊñáÁöÑÂéãÁº©Êñá‰ª∂ (ÊîØÊåÅ .zip, .tar, .tar.gz)')
    }

    environment {
        // Harbor ‰ªìÂ∫ìÈÖçÁΩÆ
        HARBOR_REGISTRY = "registry.test.shifu.dev"
        HARBOR_PROJECT = "test-project"
        DOCKER_USER = "admin"
        DOCKER_PASS = 'harbor-credentials'  // Jenkins Âá≠ÊçÆ ID
        
        // ÈïúÂÉèÈÖçÁΩÆ
        IMAGE_NAME = "${HARBOR_REGISTRY}/${HARBOR_PROJECT}/${params.APP_NAME}"
        IMAGE_TAG = generateImageTag()
        
        // ÊûÑÂª∫ÈÖçÁΩÆ
        DOCKERFILE_PATH = "${params.BUILD_CONTEXT}/Dockerfile"
        BUILD_CONTEXT_PATH = "${params.BUILD_CONTEXT}"
        
        // Âπ≥Âè∞ÈÖçÁΩÆ
        BUILD_PLATFORMS = "${params.BUILD_PLATFORMS}"
    }

    stages {
        stage("Ê∏ÖÁêÜÂ∑•‰ΩúÁ©∫Èó¥") {
            steps {
                cleanWs()
            }
        }

        stage("Â§ÑÁêÜ‰∏ä‰º†Êñá‰ª∂") {
            steps {
                script {
                    echo "üì¶ ÂºÄÂßãÂ§ÑÁêÜ‰∏ä‰º†ÁöÑÊûÑÂª∫Êñá‰ª∂"
                    
                    // Ëé∑Âèñ‰∏ä‰º†Êñá‰ª∂ÁöÑÂéüÂßãÊñá‰ª∂Âêç
                    def originalFilename = env.BUILD_ARCHIVE_FILENAME
                    echo "‰∏ä‰º†Êñá‰ª∂Âêç: ${originalFilename}"
                    
                    // ‰ªé stash ‰∏≠ÊÅ¢Â§ç‰∏ä‰º†ÁöÑÊñá‰ª∂
                    unstash 'BUILD_ARCHIVE'
                    
                    // Ê£ÄÊü•Êñá‰ª∂Âπ∂Á°ÆÂÆöÂÆûÈôÖÊñá‰ª∂Âêç
                    sh """
                        echo "üìã Ê£ÄÊü•‰∏ä‰º†Êñá‰ª∂‰ø°ÊÅØ..."
                        ls -la BUILD_ARCHIVE* || true
                        
                        # Ê£ÄÊü•ÊòØÂê¶ÊúâÂéüÂßãÊñá‰ª∂Âêç
                        if [ -n "\${BUILD_ARCHIVE_FILENAME}" ] && [ "\${BUILD_ARCHIVE_FILENAME}" != "null" ]; then
                            echo "‚úÖ ‰ΩøÁî®ÂéüÂßãÊñá‰ª∂Âêç: \${BUILD_ARCHIVE_FILENAME}"
                            if [ -f "BUILD_ARCHIVE" ]; then
                                mv BUILD_ARCHIVE "\${BUILD_ARCHIVE_FILENAME}"
                            fi
                            ARCHIVE_FILE="\${BUILD_ARCHIVE_FILENAME}"
                        else
                            echo "‚ö†Ô∏è  Êñá‰ª∂Âêç‰∏∫Á©∫ÊàñnullÔºåÂ∞ùËØïÊ£ÄÊµãÊñá‰ª∂Á±ªÂûã"
                            # ‰ΩøÁî® file ÂëΩ‰ª§Ê£ÄÊµãÊñá‰ª∂Á±ªÂûã
                            FILE_TYPE=\$(file BUILD_ARCHIVE 2>/dev/null || echo "unknown")
                            echo "Êñá‰ª∂Á±ªÂûãÊ£ÄÊµã: \$FILE_TYPE"
                            
                            if echo "\$FILE_TYPE" | grep -q "Zip archive"; then
                                ARCHIVE_FILE="BUILD_ARCHIVE.zip"
                                mv BUILD_ARCHIVE "\$ARCHIVE_FILE"
                                echo "‚úÖ Ê£ÄÊµã‰∏∫ZIPÊñá‰ª∂ÔºåÈáçÂëΩÂêç‰∏∫: \$ARCHIVE_FILE"
                            elif echo "\$FILE_TYPE" | grep -q "gzip compressed"; then
                                ARCHIVE_FILE="BUILD_ARCHIVE.tar.gz"
                                mv BUILD_ARCHIVE "\$ARCHIVE_FILE"
                                echo "‚úÖ Ê£ÄÊµã‰∏∫TAR.GZÊñá‰ª∂ÔºåÈáçÂëΩÂêç‰∏∫: \$ARCHIVE_FILE"
                            elif echo "\$FILE_TYPE" | grep -q "POSIX tar archive"; then
                                ARCHIVE_FILE="BUILD_ARCHIVE.tar"
                                mv BUILD_ARCHIVE "\$ARCHIVE_FILE"
                                echo "‚úÖ Ê£ÄÊµã‰∏∫TARÊñá‰ª∂ÔºåÈáçÂëΩÂêç‰∏∫: \$ARCHIVE_FILE"
                            else
                                ARCHIVE_FILE="BUILD_ARCHIVE"
                                echo "‚ö†Ô∏è  Êó†Ê≥ïËØÜÂà´Êñá‰ª∂Á±ªÂûãÔºå‰ΩøÁî®ÈªòËÆ§ÂêçÁß∞: \$ARCHIVE_FILE"
                            fi
                        fi
                        
                        echo "ÊúÄÁªà‰ΩøÁî®ÁöÑÊñá‰ª∂Âêç: \$ARCHIVE_FILE"
                        echo "ARCHIVE_FILE=\$ARCHIVE_FILE" > archive_info.env
                    """
                    
                    // ËØªÂèñÊñá‰ª∂Âêç‰ø°ÊÅØ
                    def archiveInfo = readFile('archive_info.env').trim()
                    def archiveFile = archiveInfo.split('=')[1]
                    env.ACTUAL_ARCHIVE_FILE = archiveFile
                    
                    echo "Á°ÆÂÆöÁöÑÂΩíÊ°£Êñá‰ª∂: ${env.ACTUAL_ARCHIVE_FILE}"
                    
                    // Ê£ÄÊµãÊñá‰ª∂Á±ªÂûãÂπ∂Ëß£Âéã - ‰ΩøÁî® Pipeline Utility Steps
                    script {
                        def uploadedArchive = env.ACTUAL_ARCHIVE_FILE
                        
                        echo "üìã Êñá‰ª∂‰ø°ÊÅØ:"
                        sh "ls -lh '${uploadedArchive}'"
                        
                        echo "üìÇ ÂºÄÂßãËß£ÂéãÊñá‰ª∂: ${uploadedArchive}"
                        
                        // Ê†πÊçÆÊñá‰ª∂Êâ©Â±ïÂêç‰ΩøÁî®ÈÄÇÂΩìÁöÑ Pipeline Utility Steps
                        try {
                            if (uploadedArchive.endsWith('.zip')) {
                                echo "‰ΩøÁî® Pipeline Utility Steps unzip Ëß£Âéã ZIP Êñá‰ª∂"
                                unzip zipFile: uploadedArchive, quiet: false
                                echo "‚úÖ ZIP Êñá‰ª∂Ëß£ÂéãÂÆåÊàê"
                            } else if (uploadedArchive.endsWith('.tar.gz') || uploadedArchive.endsWith('.tgz')) {
                                echo "‰ΩøÁî® Pipeline Utility Steps untar Ëß£Âéã TAR.GZ Êñá‰ª∂"
                                untar file: uploadedArchive, compression: 'gzip', quiet: false
                                echo "‚úÖ TAR.GZ Êñá‰ª∂Ëß£ÂéãÂÆåÊàê"
                            } else if (uploadedArchive.endsWith('.tar')) {
                                echo "‰ΩøÁî® Pipeline Utility Steps untar Ëß£Âéã TAR Êñá‰ª∂"
                                untar file: uploadedArchive, quiet: false
                                echo "‚úÖ TAR Êñá‰ª∂Ëß£ÂéãÂÆåÊàê"
                            } else {
                                echo "‚ö†Ô∏è  Êú™Áü•Êñá‰ª∂Ê†ºÂºèÔºåÂ∞ùËØïÈÄöÁî®Ëß£ÂéãÊñπÊ≥ï"
                                // ÂÖàÂ∞ùËØï‰Ωú‰∏∫ ZIP Êñá‰ª∂
                                try {
                                    echo "Â∞ùËØïÊåâ ZIP Ê†ºÂºèËß£Âéã"
                                    unzip zipFile: uploadedArchive, quiet: false
                                    echo "‚úÖ Êåâ ZIP Ê†ºÂºèËß£ÂéãÊàêÂäü"
                                } catch (Exception zipEx) {
                                    echo "ZIP Ëß£ÂéãÂ§±Ë¥•ÔºåÂ∞ùËØïÊåâ TAR Ê†ºÂºèËß£Âéã"
                                    try {
                                        untar file: uploadedArchive, quiet: false
                                        echo "‚úÖ Êåâ TAR Ê†ºÂºèËß£ÂéãÊàêÂäü"
                                    } catch (Exception tarEx) {
                                        echo "TAR Ëß£ÂéãÂ§±Ë¥•ÔºåÂ∞ùËØïÊåâ TAR.GZ Ê†ºÂºèËß£Âéã"
                                        untar file: uploadedArchive, compression: 'gzip', quiet: false
                                        echo "‚úÖ Êåâ TAR.GZ Ê†ºÂºèËß£ÂéãÊàêÂäü"
                                    }
                                }
                            }
                        } catch (Exception e) {
                            echo "‚ùå Pipeline Utility Steps Ëß£ÂéãÂ§±Ë¥•: ${e.getMessage()}"
                            echo "ÂõûÈÄÄÂà∞‰º†ÁªüÊñπÊ≥ïËß£Âéã..."
                            
                            // ÂõûÈÄÄÂà∞‰º†ÁªüÂëΩ‰ª§Ë°åËß£Âéã
                            if (uploadedArchive.endsWith('.zip')) {
                                echo "‰ΩøÁî® Python Ëß£Âéã ZIP Êñá‰ª∂"
                                sh '''
                                    python3 -c "
import zipfile
import sys
try:
    with zipfile.ZipFile('${uploadedArchive}', 'r') as zip_ref:
        zip_ref.extractall('.')
    print('‚úÖ Python ZIP Ëß£ÂéãÊàêÂäü')
except Exception as e:
    print(f'‚ùå Python ZIP Ëß£ÂéãÂ§±Ë¥•: {e}')
    sys.exit(1)
                                    "
                                '''
                            } else if (uploadedArchive.endsWith('.tar.gz') || uploadedArchive.endsWith('.tgz')) {
                                echo "‰ΩøÁî® tar Ëß£Âéã TAR.GZ Êñá‰ª∂"
                                sh "tar -xzf '${uploadedArchive}'"
                            } else if (uploadedArchive.endsWith('.tar')) {
                                echo "‰ΩøÁî® tar Ëß£Âéã TAR Êñá‰ª∂"
                                sh "tar -xf '${uploadedArchive}'"
                            }
                        }
                        
                        echo "üìÅ Ëß£ÂéãÂêéÂ∑•‰ΩúÁ©∫Èó¥ÂÜÖÂÆπ:"
                        sh "ls -la"
                    }
                    
                    // È™åËØÅÊûÑÂª∫ÁõÆÂΩïÂíåÊñá‰ª∂ÊòØÂê¶Â≠òÂú®
                    sh """
                        if [ ! -d "${BUILD_CONTEXT_PATH}" ]; then
                            echo "‚ùå ÈîôËØØ: ÊûÑÂª∫ÁõÆÂΩï ${BUILD_CONTEXT_PATH} ‰∏çÂ≠òÂú®"
                            echo "üìÅ ÂΩìÂâçÁõÆÂΩïÂÜÖÂÆπ:"
                            find . -type d -maxdepth 2
                            exit 1
                        fi
                        
                        if [ ! -f "${DOCKERFILE_PATH}" ]; then
                            echo "‚ùå ÈîôËØØ: Dockerfile ${DOCKERFILE_PATH} ‰∏çÂ≠òÂú®"
                            echo "üìÅ ÊûÑÂª∫ÁõÆÂΩïÂÜÖÂÆπ:"
                            ls -la ${BUILD_CONTEXT_PATH}/
                            exit 1
                        fi
                        
                        echo "‚úÖ ÊûÑÂª∫Êñá‰ª∂È™åËØÅÈÄöËøá"
                        echo "üìÅ ÊûÑÂª∫ÁõÆÂΩïÂÜÖÂÆπ:"
                        ls -la ${BUILD_CONTEXT_PATH}/
                    """
                }
            }
        }

        stage("ÊûÑÂª∫ÂáÜÂ§á") {
            steps {
                script {
                    echo "üîß ÊûÑÂª∫ÂáÜÂ§áÈò∂ÊÆµ"
                    
                    // Â§ÑÁêÜÂîØ‰∏ÄID - ÈÄöÂ∏∏Áî±PythonËÑöÊú¨ÁîüÊàêÂπ∂‰º†ÈÄí
                    def uniqueId = params.BUILD_UNIQUE_ID
                    if (!uniqueId || uniqueId.trim().isEmpty()) {
                        uniqueId = "${new Date().format('yyyyMMddHHmmss')}-${BUILD_NUMBER}-${UUID.randomUUID().toString().substring(0, 8)}"
                        echo "üìã JenkinsÁîüÊàêÂîØ‰∏ÄID: ${uniqueId}"
                    } else {
                        echo "üìã ‰ΩøÁî®‰º†ÈÄíÁöÑÂîØ‰∏ÄID: ${uniqueId}"
                    }
                    env.ACTUAL_UNIQUE_ID = uniqueId
                    
                    // Â§ÑÁêÜÂπ≥Âè∞ÈÖçÁΩÆ
                    def platformsStr = params.BUILD_PLATFORMS
                    echo "üîç ÂéüÂßãÂπ≥Âè∞ÂèÇÊï∞: '${platformsStr}'"
                    
                    def platforms = platformsStr.split(',')
                    def platformsInfo = []
                    
                    echo "üèóÔ∏è  Â§öÂπ≥Âè∞ÊûÑÂª∫ÈÖçÁΩÆ:"
                    echo "   ÈÄâÊã©ÁöÑÂπ≥Âè∞: ${platformsStr}"
                    echo "   ÂàÜÂâ≤ÂêéÂπ≥Âè∞Êï∞Èáè: ${platforms.length}"
                    
                    for (platform in platforms) {
                        def cleanPlatform = platform.trim()
                        platformsInfo.add(cleanPlatform)
                        echo "   - Âπ≥Âè∞: '${cleanPlatform}'"
                    }
                    
                    env.PLATFORM_LIST = platformsInfo.join(',')
                    env.IS_MULTI_PLATFORM = (platforms.length > 1).toString()
                    
                    echo "üîç ÁéØÂ¢ÉÂèòÈáèËÆæÁΩÆ:"
                    echo "   PLATFORM_LIST: '${env.PLATFORM_LIST}'"
                    echo "   IS_MULTI_PLATFORM: '${env.IS_MULTI_PLATFORM}'"
                    
                    echo "üìã ÊûÑÂª∫ÈÖçÁΩÆ‰ø°ÊÅØ:"
                    echo "   Â∫îÁî®ÂêçÁß∞: ${params.APP_NAME}"
                    echo "   Â∫îÁî®ÁâàÊú¨: ${params.APP_VERSION}" 
                    echo "   ÊûÑÂª∫ÂîØ‰∏ÄID: ${uniqueId}"
                    echo "   ÈïúÂÉèÂêçÁß∞: ${IMAGE_NAME}"
                    echo "   ÈïúÂÉèÊ†áÁ≠æ: ${IMAGE_TAG}"
                    echo "   Harbor ‰ªìÂ∫ì: ${HARBOR_REGISTRY}"
                    echo "   È°πÁõÆ: ${HARBOR_PROJECT}"
                    echo "   ÊûÑÂª∫Âπ≥Âè∞: ${env.PLATFORM_LIST}"
                    echo "   Â§öÂπ≥Âè∞ÊûÑÂª∫: ${env.IS_MULTI_PLATFORM}"
                    
                    // ÊòæÁ§∫ÊûÑÂª∫‰ø°ÊÅØ
                    sh """
                        echo "=== ÊûÑÂª∫‰ø°ÊÅØ ==="
                        echo "ÊûÑÂª∫Âè∑: ${BUILD_NUMBER}"
                        echo "ÊûÑÂª∫ÂîØ‰∏ÄID: ${uniqueId}"
                        echo "ÊûÑÂª∫Êó∂Èó¥: \$(date)"
                        echo "ÊûÑÂª∫ËäÇÁÇπ: \$(hostname)"
                        echo "Jenkins URL: ${JENKINS_URL}"
                        echo "ÂéüÂßãÊñá‰ª∂Âêç: \${BUILD_ARCHIVE_FILENAME:-'Êú™ËÆæÁΩÆ'}"
                        echo "ÂÆûÈôÖ‰ΩøÁî®Êñá‰ª∂: ${env.ACTUAL_ARCHIVE_FILE}"
                        echo "ÊûÑÂª∫Âπ≥Âè∞: ${env.PLATFORM_LIST}"
                        echo "Â§öÂπ≥Âè∞Ê®°Âºè: ${env.IS_MULTI_PLATFORM}"
                    """
                }
            }
        }

        stage("Â§öÂπ≥Âè∞ÈïúÂÉèÊûÑÂª∫") {
            steps {
                script {
                    def platforms = env.PLATFORM_LIST.split(',')
                    echo "üöÄ ÂºÄÂßãÊûÑÂª∫ ${platforms.length} ‰∏™Âπ≥Âè∞: ${env.PLATFORM_LIST}"
                }
            }
        }
        
        stage("Âπ∂Ë°åÊûÑÂª∫ÊâßË°å") {
            failFast false  // Êîπ‰∏∫‰∏çÂø´ÈÄüÂ§±Ë¥•ÔºåËÆ©‰∏Ä‰∏™Âπ≥Âè∞Â§±Ë¥•Êó∂Âè¶‰∏Ä‰∏™Âπ≥Âè∞ÂèØ‰ª•ÁªßÁª≠
            parallel {
                stage('ÊûÑÂª∫ AMD64') {
                    when {
                        expression { 
                            return env.PLATFORM_LIST.contains('linux/amd64')
                        }
                    }
                    steps {
                        script {
                            echo "üñ•Ô∏è  ÊûÑÂª∫ AMD64 ÈïúÂÉè"
                            buildPlatformImage('linux/amd64', 'amd64')
                        }
                    }
                    post {
                        failure {
                            echo "‚ùå AMD64 Â§±Ë¥•"
                        }
                    }
                }
                
                stage('ÊûÑÂª∫ ARM64') {
                    when {
                        expression { 
                            return env.PLATFORM_LIST.contains('linux/arm64')
                        }
                    }
                    steps {
                        script {
                            echo "üí™ ÊûÑÂª∫ ARM64 ÈïúÂÉè"
                            buildPlatformImage('linux/arm64', 'arm64')
                        }
                    }
                    post {
                        failure {
                            echo "‚ùå ARM64 Â§±Ë¥•"
                        }
                    }
                }
            }
        }



        stage("ÊûÑÂª∫ÁªìÊûúÊ±áÊÄª") {
            steps {
                script {
                    def platforms = env.PLATFORM_LIST.split(',')
                    def builtPlatforms = []
                    
                    for (platform in platforms) {
                        def cleanPlatform = platform.trim()
                        if (cleanPlatform == 'linux/amd64' || cleanPlatform == 'linux/arm64') {
                            builtPlatforms.add(cleanPlatform)
                        }
                    }
                    
                    echo "üìä ÊûÑÂª∫ÂÆåÊàê: ${params.APP_NAME}:${IMAGE_TAG} (${builtPlatforms.size()}Âπ≥Âè∞)"
                    echo ""
                    echo "üéØ ÊûÑÂª∫ÁöÑÈïúÂÉè:"
                    
                    for (platform in builtPlatforms) {
                        def platformArch = platform.replace('linux/', '')
                        echo "   ${IMAGE_NAME}:${IMAGE_TAG}-${platformArch}"
                        echo "   ${IMAGE_NAME}:latest-${platformArch}"
                    }
                    
                    
                }
            }
        }
    }

    post {
        always {
            script {
                echo "üßπ ÊûÑÂª∫ÂÆåÊàê - ÁºñÂè∑: ${BUILD_NUMBER}"
            }
        }
        success {
            script {
                def platforms = env.PLATFORM_LIST?.split(',') ?: []
                def builtPlatforms = []
                
                for (platform in platforms) {
                    def cleanPlatform = platform.trim()
                    if (cleanPlatform == 'linux/amd64' || cleanPlatform == 'linux/arm64') {
                        builtPlatforms.add(cleanPlatform.replace('linux/', ''))
                    }
                }
                
                echo "üéâ ÊûÑÂª∫ÊàêÂäü - ${params.APP_NAME}:${IMAGE_TAG}"
                echo "‚úÖ Âπ≥Âè∞: ${builtPlatforms.join(', ')}"
            }
        }
        failure {
            script {
                echo "‚ùå ÊûÑÂª∫Â§±Ë¥• - ${params.APP_NAME}:${IMAGE_TAG}"
            }
        }
    }
}

// ÁîüÊàêÈïúÂÉèÊ†áÁ≠æÁöÑÂáΩÊï∞
def generateImageTag() {
    def strategy = params.IMAGE_TAG_STRATEGY ?: 'version-build'
    
    switch(strategy) {
        case 'version-build':
            return "${params.APP_VERSION}"
        case 'timestamp':
            return "${params.APP_VERSION}-${new Date().format('yyyyMMdd-HHmmss')}"
        case 'latest':
            return 'latest'
        default:
            return "${params.APP_VERSION}"
    }
}

// Ëß£ÊûêÂπ≥Âè∞ÂàóË°®ÁöÑÂáΩÊï∞
def parsePlatforms(platformsStr) {
    return platformsStr.split(',').collect { it.trim() }.join(',')
}

// ÊûÑÂª∫ÊåáÂÆöÂπ≥Âè∞ÈïúÂÉèÁöÑÂáΩÊï∞ÔºàÂ∏¶ÈáçËØïÊú∫Âà∂Ôºâ
def buildPlatformImage(String platform, String platformArch) {
    container(name: 'kaniko', shell: '/bin/sh') {
        // Ê∑ªÂä†ÈöèÊú∫Âª∂Ëøü‰ª•ÈÅøÂÖçÂπ∂ÂèëÂÜ≤Á™Å
        def delay = new Random().nextInt(10) + 1
        echo "‚è≥ ${platformArch} ÊûÑÂª∫Âª∂Ëøü ${delay} Áßí‰ª•ÈÅøÂÖçÂπ∂ÂèëÂÜ≤Á™Å..."
        sleep delay
        
        retry(3) {  // ÊúÄÂ§öÈáçËØï3Ê¨°
            sh """#!/bin/sh
                # ÊµãËØïshellÁéØÂ¢É
                echo "üîç Testing shell environment..."
                echo "Current working directory: \$(pwd)"
                echo "Available shells: \$(ls -la /bin/*sh 2>/dev/null || echo 'No shells found in /bin')"
                echo "Kaniko executor: \$(ls -la /kaniko/executor)"
                
                # È™åËØÅÊñá‰ª∂
                if [ ! -f "${DOCKERFILE_PATH}" ]; then
                    echo "‚ùå Dockerfile ‰∏çÂ≠òÂú®: ${DOCKERFILE_PATH}"
                    exit 1
                fi
                
                # ÊâßË°åÊûÑÂª∫
                /kaniko/executor \\
                    --dockerfile=${DOCKERFILE_PATH} \\
                    --context=${BUILD_CONTEXT_PATH} \\
                    --destination=${IMAGE_NAME}:${IMAGE_TAG}-${platformArch} \\
                    --destination=${IMAGE_NAME}:latest-${platformArch} \\
                    --custom-platform=${platform} \\
                    --build-arg=TARGETARCH=${platformArch} \\
                    --build-arg=BUILDPLATFORM=${platform} \\
                    --cache=true \\
                    --cache-ttl=24h \\
                    --cleanup
            """
        }
    }
} 