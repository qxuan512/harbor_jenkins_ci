pipeline {
    agent {
        kubernetes {
            yaml '''
                kind: Pod
                spec:
                  containers:
                  - name: kaniko
                    image: gcr.io/kaniko-project/executor:debug
                    imagePullPolicy: Always
                    command:
                    - sleep
                    args:
                    - 9999999
                    volumeMounts:
                      - name: jenkins-docker-cfg
                        mountPath: /kaniko/.docker
                    env:
                    - name: DOCKER_CONFIG
                      value: /kaniko/.docker
                    - name: KANIKO_INSECURE_REGISTRIES
                      value: "registry.test.shifu.dev"
                    - name: KANIKO_INSECURE
                      value: "true"
                    - name: KANIKO_SKIP_TLS_VERIFY
                      value: "true"
                  volumes:
                  - name: jenkins-docker-cfg
                    projected:
                      sources:
                      - secret:
                          name: harbor-credentials
                          items:
                            - key: .dockerconfigjson
                              path: config.json
            '''
        }
    }

    parameters {
        // 允许外部程序通过参数触发构建
        string(name: 'APP_NAME', defaultValue: 'iot-driver', description: '应用名称')
        string(name: 'APP_VERSION', defaultValue: '1.0.0', description: '应用版本')
        string(name: 'BUILD_CONTEXT', defaultValue: 'example_direct_upload', description: '构建上下文目录')
        choice(name: 'IMAGE_TAG_STRATEGY', choices: ['version-build-unique', 'version-build', 'timestamp', 'latest'], description: '镜像标签策略')
        // 添加文件上传参数
        stashedFile(name: 'BUILD_ARCHIVE', description: '上传包含构建上下文的压缩文件 (支持 .zip, .tar, .tar.gz)')
    }

    environment {
        // Harbor 仓库配置
        HARBOR_REGISTRY = "registry.test.shifu.dev"
        HARBOR_PROJECT = "test-project"
        DOCKER_USER = "admin"
        DOCKER_PASS = 'harbor-credentials'  // Jenkins 凭据 ID
        
        // 镜像配置
        IMAGE_NAME = "${HARBOR_REGISTRY}/${HARBOR_PROJECT}/${params.APP_NAME}"
        
        // 构建配置
        DOCKERFILE_PATH = "${params.BUILD_CONTEXT}/Dockerfile"
        BUILD_CONTEXT_PATH = "${params.BUILD_CONTEXT}"
        
        // 唯一构建标识符（将在构建准备阶段生成）
        UNIQUE_BUILD_ID = ""
        IMAGE_TAG = ""
    }

    stages {
        stage("清理工作空间") {
            steps {
                cleanWs()
            }
        }

        stage("处理上传文件") {
            steps {
                script {
                    echo "📦 开始处理上传的构建文件"
                    
                    // 获取上传文件的原始文件名
                    def originalFilename = env.BUILD_ARCHIVE_FILENAME
                    echo "上传文件名: ${originalFilename}"
                    
                    // 从 stash 中恢复上传的文件
                    unstash 'BUILD_ARCHIVE'
                    
                    // 检查文件并确定实际文件名
                    sh """
                        echo "📋 检查上传文件信息..."
                        ls -la BUILD_ARCHIVE* || true
                        
                        # 检查是否有原始文件名
                        if [ -n "\${BUILD_ARCHIVE_FILENAME}" ] && [ "\${BUILD_ARCHIVE_FILENAME}" != "null" ]; then
                            echo "✅ 使用原始文件名: \${BUILD_ARCHIVE_FILENAME}"
                            if [ -f "BUILD_ARCHIVE" ]; then
                                mv BUILD_ARCHIVE "\${BUILD_ARCHIVE_FILENAME}"
                            fi
                            ARCHIVE_FILE="\${BUILD_ARCHIVE_FILENAME}"
                        else
                            echo "⚠️  文件名为空或null，尝试检测文件类型"
                            # 使用 file 命令检测文件类型
                            FILE_TYPE=\$(file BUILD_ARCHIVE 2>/dev/null || echo "unknown")
                            echo "文件类型检测: \$FILE_TYPE"
                            
                            if echo "\$FILE_TYPE" | grep -q "Zip archive"; then
                                ARCHIVE_FILE="BUILD_ARCHIVE.zip"
                                mv BUILD_ARCHIVE "\$ARCHIVE_FILE"
                                echo "✅ 检测为ZIP文件，重命名为: \$ARCHIVE_FILE"
                            elif echo "\$FILE_TYPE" | grep -q "gzip compressed"; then
                                ARCHIVE_FILE="BUILD_ARCHIVE.tar.gz"
                                mv BUILD_ARCHIVE "\$ARCHIVE_FILE"
                                echo "✅ 检测为TAR.GZ文件，重命名为: \$ARCHIVE_FILE"
                            elif echo "\$FILE_TYPE" | grep -q "POSIX tar archive"; then
                                ARCHIVE_FILE="BUILD_ARCHIVE.tar"
                                mv BUILD_ARCHIVE "\$ARCHIVE_FILE"
                                echo "✅ 检测为TAR文件，重命名为: \$ARCHIVE_FILE"
                            else
                                ARCHIVE_FILE="BUILD_ARCHIVE"
                                echo "⚠️  无法识别文件类型，使用默认名称: \$ARCHIVE_FILE"
                            fi
                        fi
                        
                        echo "最终使用的文件名: \$ARCHIVE_FILE"
                        echo "ARCHIVE_FILE=\$ARCHIVE_FILE" > archive_info.env
                    """
                    
                    // 读取文件名信息
                    def archiveInfo = readFile('archive_info.env').trim()
                    def archiveFile = archiveInfo.split('=')[1]
                    env.ACTUAL_ARCHIVE_FILE = archiveFile
                    
                    echo "确定的归档文件: ${env.ACTUAL_ARCHIVE_FILE}"
                    
                    // 检测文件类型并解压 - 使用 Pipeline Utility Steps
                    script {
                        def uploadedArchive = env.ACTUAL_ARCHIVE_FILE
                        
                        echo "📋 文件信息:"
                        sh "ls -lh '${uploadedArchive}'"
                        
                        echo "📂 开始解压文件: ${uploadedArchive}"
                        
                        // 根据文件扩展名使用适当的 Pipeline Utility Steps
                        try {
                            if (uploadedArchive.endsWith('.zip')) {
                                echo "使用 Pipeline Utility Steps unzip 解压 ZIP 文件"
                                unzip zipFile: uploadedArchive, quiet: false
                                echo "✅ ZIP 文件解压完成"
                            } else if (uploadedArchive.endsWith('.tar.gz') || uploadedArchive.endsWith('.tgz')) {
                                echo "使用 Pipeline Utility Steps untar 解压 TAR.GZ 文件"
                                untar file: uploadedArchive, compression: 'gzip', quiet: false
                                echo "✅ TAR.GZ 文件解压完成"
                            } else if (uploadedArchive.endsWith('.tar')) {
                                echo "使用 Pipeline Utility Steps untar 解压 TAR 文件"
                                untar file: uploadedArchive, quiet: false
                                echo "✅ TAR 文件解压完成"
                            } else {
                                echo "⚠️  未知文件格式，尝试通用解压方法"
                                // 先尝试作为 ZIP 文件
                                try {
                                    echo "尝试按 ZIP 格式解压"
                                    unzip zipFile: uploadedArchive, quiet: false
                                    echo "✅ 按 ZIP 格式解压成功"
                                } catch (Exception zipEx) {
                                    echo "ZIP 解压失败，尝试按 TAR 格式解压"
                                    try {
                                        untar file: uploadedArchive, quiet: false
                                        echo "✅ 按 TAR 格式解压成功"
                                    } catch (Exception tarEx) {
                                        echo "TAR 解压失败，尝试按 TAR.GZ 格式解压"
                                        untar file: uploadedArchive, compression: 'gzip', quiet: false
                                        echo "✅ 按 TAR.GZ 格式解压成功"
                                    }
                                }
                            }
                        } catch (Exception e) {
                            echo "❌ Pipeline Utility Steps 解压失败: ${e.getMessage()}"
                            echo "回退到传统方法解压..."
                            
                            // 回退到传统命令行解压
                            if (uploadedArchive.endsWith('.zip')) {
                                echo "使用 Python 解压 ZIP 文件"
                                sh '''
                                    python3 -c "
import zipfile
import sys
try:
    with zipfile.ZipFile('${uploadedArchive}', 'r') as zip_ref:
        zip_ref.extractall('.')
    print('✅ Python ZIP 解压成功')
except Exception as e:
    print(f'❌ Python ZIP 解压失败: {e}')
    sys.exit(1)
                                    "
                                '''
                            } else if (uploadedArchive.endsWith('.tar.gz') || uploadedArchive.endsWith('.tgz')) {
                                echo "使用 tar 解压 TAR.GZ 文件"
                                sh "tar -xzf '${uploadedArchive}'"
                            } else if (uploadedArchive.endsWith('.tar')) {
                                echo "使用 tar 解压 TAR 文件"
                                sh "tar -xf '${uploadedArchive}'"
                            }
                        }
                        
                        echo "📁 解压后工作空间内容:"
                        sh "ls -la"
                    }
                    
                    // 验证构建目录和文件是否存在
                    sh """
                        if [ ! -d "${BUILD_CONTEXT_PATH}" ]; then
                            echo "❌ 错误: 构建目录 ${BUILD_CONTEXT_PATH} 不存在"
                            echo "📁 当前目录内容:"
                            find . -type d -maxdepth 2
                            exit 1
                        fi
                        
                        if [ ! -f "${DOCKERFILE_PATH}" ]; then
                            echo "❌ 错误: Dockerfile ${DOCKERFILE_PATH} 不存在"
                            echo "📁 构建目录内容:"
                            ls -la ${BUILD_CONTEXT_PATH}/
                            exit 1
                        fi
                        
                        echo "✅ 构建文件验证通过"
                        echo "📁 构建目录内容:"
                        ls -la ${BUILD_CONTEXT_PATH}/
                    """
                }
            }
        }

        stage("构建准备") {
            steps {
                script {
                    echo "🔧 构建准备阶段"
                    
                    // 生成唯一构建标识符（解决并发构建问题）
                    echo "🔄 正在生成唯一构建标识符..."
                    def uniqueBuildId = generateUniqueBuildId()
                    echo "✅ 唯一构建ID已生成: ${uniqueBuildId}"
                    
                    // 生成镜像标签（传入uniqueBuildId避免循环依赖）
                    echo "🔄 正在生成镜像标签..."
                    def imageTag = generateImageTag(uniqueBuildId)
                    echo "✅ 镜像标签已生成: ${imageTag}"
                    
                    // 设置环境变量（使用script块内的方式）
                    env.UNIQUE_BUILD_ID = uniqueBuildId
                    env.IMAGE_TAG = imageTag
                    
                    // 验证环境变量设置
                    echo "🔍 验证环境变量设置:"
                    echo "   UNIQUE_BUILD_ID = ${env.UNIQUE_BUILD_ID}"
                    echo "   IMAGE_TAG = ${env.IMAGE_TAG}"
                    
                    echo "应用名称: ${params.APP_NAME}"
                    echo "应用版本: ${params.APP_VERSION}" 
                    echo "镜像名称: ${IMAGE_NAME}"
                    echo "镜像标签: ${imageTag}"
                    echo "唯一构建ID: ${uniqueBuildId}"
                    echo "Harbor 仓库: ${HARBOR_REGISTRY}"
                    echo "项目: ${HARBOR_PROJECT}"
                }
                
                // 在script块外部使用sh，此时环境变量应该可用
                sh '''
                    echo "=== 构建信息 ==="
                    echo "Jenkins构建号: ${BUILD_NUMBER}"
                    echo "唯一构建ID: ${UNIQUE_BUILD_ID}"
                    echo "镜像标签: ${IMAGE_TAG}"
                    echo "构建时间: $(date)"
                    echo "构建节点: $(hostname)"
                    echo "Jenkins URL: ${JENKINS_URL}"
                    echo "原始文件名: ${BUILD_ARCHIVE_FILENAME:-'未设置'}"
                    echo "实际使用文件: ${ACTUAL_ARCHIVE_FILE}"
                    echo "构建策略: ${IMAGE_TAG_STRATEGY}"
                '''
            }
        }

        stage("使用 Kaniko 构建并推送镜像") {
            steps {
                container(name: 'kaniko', shell: '/busybox/sh') {
                    sh '''#!/busybox/sh
                        echo "🚀 开始使用 Kaniko 构建 Docker 镜像"
                        echo "📋 构建标识信息:"
                        echo "   Jenkins构建号: ${BUILD_NUMBER}"
                        echo "   唯一构建ID: ${UNIQUE_BUILD_ID}"
                        echo "   镜像标签: ${IMAGE_TAG}"
                        
                        # 显示 Kaniko 版本
                        /kaniko/executor version
                        
                        # 显示构建上下文
                        echo "📂 构建上下文内容:"
                        ls -la ${BUILD_CONTEXT_PATH}/
                        
                        # 执行镜像构建和推送
                        echo "🔨 开始构建镜像: ${IMAGE_NAME}:${IMAGE_TAG}"
                        
                        /kaniko/executor \\
                            --dockerfile=${DOCKERFILE_PATH} \\
                            --context=${BUILD_CONTEXT_PATH} \\
                            --destination=${IMAGE_NAME}:${IMAGE_TAG} \\
                            --destination=${IMAGE_NAME}:latest \\
                            --cache=true \\
                            --cache-ttl=24h \\
                            --cleanup
                        
                        echo "✅ 镜像构建并推送完成"
                        echo "📦 推送的镜像:"
                        echo "   - ${IMAGE_NAME}:${IMAGE_TAG}"
                        echo "   - ${IMAGE_NAME}:latest"
                        echo "🆔 唯一构建标识: ${UNIQUE_BUILD_ID}"
                    '''
                }
            }
        }

        stage("验证镜像推送") {
            steps {
                script {
                    echo "🔍 验证镜像是否成功推送到 Harbor"
                    
                    // 这里可以添加验证逻辑，比如调用 Harbor API 检查镜像是否存在
                    sh """
                        echo "镜像推送验证:"
                        echo "仓库地址: ${HARBOR_REGISTRY}"
                        echo "项目: ${HARBOR_PROJECT}"
                        echo "镜像: ${params.APP_NAME}:${env.IMAGE_TAG}"
                        echo "唯一构建ID: ${env.UNIQUE_BUILD_ID}"
                        
                        # 可以添加 Harbor API 调用来验证镜像
                        # curl -u admin:password ${HARBOR_REGISTRY}/api/v2.0/projects/${HARBOR_PROJECT}/repositories/${params.APP_NAME}/artifacts
                    """
                }
            }
        }
    }

    post {
        always {
            script {
                echo "🧹 清理构建环境"
                echo "📋 构建完成信息:"
                echo "   Jenkins构建号: ${BUILD_NUMBER}"
                echo "   唯一构建ID: ${env.UNIQUE_BUILD_ID}"
                echo "   镜像标签: ${env.IMAGE_TAG}"
            }
        }
        success {
            script {
                echo "🎉 构建成功!"
                echo "📦 镜像已推送到: ${IMAGE_NAME}:${env.IMAGE_TAG}"
                echo "🆔 唯一构建标识: ${env.UNIQUE_BUILD_ID}"
                
                // 可以在这里添加成功通知，比如发送到企业微信、钉钉等
                // notifySuccess()
            }
        }
        failure {
            script {
                echo "❌ 构建失败!"
                echo "🆔 失败的构建标识: ${env.UNIQUE_BUILD_ID}"
                
                // 可以在这里添加失败通知
                // notifyFailure()
            }
        }
    }
}

// 生成唯一构建标识符的函数（解决并发构建问题）
def generateUniqueBuildId() {
    try {
        // 组合多种元素来确保唯一性
        def timestamp = new Date().format('yyyyMMdd-HHmmss-SSS')
        def randomId = java.util.UUID.randomUUID().toString().split('-')[0]
        def buildNumber = env.BUILD_NUMBER ?: "0"
        def jobName = env.JOB_NAME?.replaceAll('[^a-zA-Z0-9]', '') ?: "job"
        
        // 格式: {job}-{build}-{timestamp}-{random}
        def uniqueId = "${jobName}-${buildNumber}-${timestamp}-${randomId}".toLowerCase()
        echo "🔧 生成的唯一ID: ${uniqueId}"
        return uniqueId
    } catch (Exception e) {
        echo "❌ 生成唯一ID失败: ${e.getMessage()}"
        // 回退方案：使用时间戳
        def fallbackId = "job-${env.BUILD_NUMBER ?: '0'}-${new Date().format('yyyyMMddHHmmssSSS')}"
        echo "🔄 使用回退ID: ${fallbackId}"
        return fallbackId
    }
}

// 生成镜像标签的函数（支持唯一性保证）
def generateImageTag(uniqueId = null) {
    def strategy = params.IMAGE_TAG_STRATEGY ?: 'version-build-unique'
    def actualUniqueId = uniqueId ?: generateUniqueBuildId()
    
    switch(strategy) {
        case 'version-build-unique':
            // 使用唯一ID而不是BUILD_NUMBER，确保并发安全
            def shortId = actualUniqueId.split('-')[-1] // 取最后一段随机ID
            return "${params.APP_VERSION}-${BUILD_NUMBER}-${shortId}"
            
        case 'version-build':
            // 传统方式，可能在并发时有冲突
            return "${params.APP_VERSION}-${BUILD_NUMBER}"
            
        case 'timestamp':
            // 使用精确时间戳，并发安全
            return "${params.APP_VERSION}-${new Date().format('yyyyMMdd-HHmmss-SSS')}"
            
        case 'latest':
            return 'latest'
            
        default:
            // 默认使用唯一方式
            def shortId = actualUniqueId.split('-')[-1]
            return "${params.APP_VERSION}-${BUILD_NUMBER}-${shortId}"
    }
} 