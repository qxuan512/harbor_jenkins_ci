pipeline {
    agent {
        kubernetes {
            yaml '''
                kind: Pod
                spec:
                  containers:
                  - name: kaniko
                    image: gcr.io/kaniko-project/executor:debug
                    imagePullPolicy: Always
                    command:
                    - sleep
                    args:
                    - 9999999
                    volumeMounts:
                      - name: jenkins-docker-cfg
                        mountPath: /kaniko/.docker
                    env:
                    - name: DOCKER_CONFIG
                      value: /kaniko/.docker
                    - name: KANIKO_INSECURE_REGISTRIES
                      value: "registry.test.shifu.dev"
                    - name: KANIKO_INSECURE
                      value: "true"
                    - name: KANIKO_SKIP_TLS_VERIFY
                      value: "true"
                  volumes:
                  - name: jenkins-docker-cfg
                    projected:
                      sources:
                      - secret:
                          name: harbor-credentials
                          items:
                            - key: .dockerconfigjson
                              path: config.json
            '''
        }
    }

    parameters {
        // å…è®¸å¤–éƒ¨ç¨‹åºé€šè¿‡å‚æ•°è§¦å‘æ„å»º
        string(name: 'APP_NAME', defaultValue: 'iot-driver', description: 'åº”ç”¨åç§°')
        string(name: 'APP_VERSION', defaultValue: '1.0.0', description: 'åº”ç”¨ç‰ˆæœ¬')
        string(name: 'BUILD_CONTEXT', defaultValue: 'example_direct_upload', description: 'æ„å»ºä¸Šä¸‹æ–‡ç›®å½•')
        choice(name: 'IMAGE_TAG_STRATEGY', choices: ['version-build-unique', 'version-build', 'timestamp', 'latest'], description: 'é•œåƒæ ‡ç­¾ç­–ç•¥')
        // æ·»åŠ æ–‡ä»¶ä¸Šä¼ å‚æ•°
        stashedFile(name: 'BUILD_ARCHIVE', description: 'ä¸Šä¼ åŒ…å«æ„å»ºä¸Šä¸‹æ–‡çš„å‹ç¼©æ–‡ä»¶ (æ”¯æŒ .zip, .tar, .tar.gz)')
    }

    environment {
        // Harbor ä»“åº“é…ç½®
        HARBOR_REGISTRY = "registry.test.shifu.dev"
        HARBOR_PROJECT = "test-project"
        DOCKER_USER = "admin"
        DOCKER_PASS = 'harbor-credentials'  // Jenkins å‡­æ® ID
        
        // é•œåƒé…ç½®
        IMAGE_NAME = "${HARBOR_REGISTRY}/${HARBOR_PROJECT}/${params.APP_NAME}"
        
        // æ„å»ºé…ç½®
        DOCKERFILE_PATH = "${params.BUILD_CONTEXT}/Dockerfile"
        BUILD_CONTEXT_PATH = "${params.BUILD_CONTEXT}"
        
        // å”¯ä¸€æ„å»ºæ ‡è¯†ç¬¦ï¼ˆå°†åœ¨æ„å»ºå‡†å¤‡é˜¶æ®µç”Ÿæˆï¼‰
        UNIQUE_BUILD_ID = ""
        IMAGE_TAG = ""
    }

    stages {
        stage("æ¸…ç†å·¥ä½œç©ºé—´") {
            steps {
                cleanWs()
            }
        }

        stage("å¤„ç†ä¸Šä¼ æ–‡ä»¶") {
            steps {
                script {
                    echo "ğŸ“¦ å¼€å§‹å¤„ç†ä¸Šä¼ çš„æ„å»ºæ–‡ä»¶"
                    
                    // è·å–ä¸Šä¼ æ–‡ä»¶çš„åŸå§‹æ–‡ä»¶å
                    def originalFilename = env.BUILD_ARCHIVE_FILENAME
                    echo "ä¸Šä¼ æ–‡ä»¶å: ${originalFilename}"
                    
                    // ä» stash ä¸­æ¢å¤ä¸Šä¼ çš„æ–‡ä»¶
                    unstash 'BUILD_ARCHIVE'
                    
                    // æ£€æŸ¥æ–‡ä»¶å¹¶ç¡®å®šå®é™…æ–‡ä»¶å
                    sh """
                        echo "ğŸ“‹ æ£€æŸ¥ä¸Šä¼ æ–‡ä»¶ä¿¡æ¯..."
                        ls -la BUILD_ARCHIVE* || true
                        
                        # æ£€æŸ¥æ˜¯å¦æœ‰åŸå§‹æ–‡ä»¶å
                        if [ -n "\${BUILD_ARCHIVE_FILENAME}" ] && [ "\${BUILD_ARCHIVE_FILENAME}" != "null" ]; then
                            echo "âœ… ä½¿ç”¨åŸå§‹æ–‡ä»¶å: \${BUILD_ARCHIVE_FILENAME}"
                            if [ -f "BUILD_ARCHIVE" ]; then
                                mv BUILD_ARCHIVE "\${BUILD_ARCHIVE_FILENAME}"
                            fi
                            ARCHIVE_FILE="\${BUILD_ARCHIVE_FILENAME}"
                        else
                            echo "âš ï¸  æ–‡ä»¶åä¸ºç©ºæˆ–nullï¼Œå°è¯•æ£€æµ‹æ–‡ä»¶ç±»å‹"
                            # ä½¿ç”¨ file å‘½ä»¤æ£€æµ‹æ–‡ä»¶ç±»å‹
                            FILE_TYPE=\$(file BUILD_ARCHIVE 2>/dev/null || echo "unknown")
                            echo "æ–‡ä»¶ç±»å‹æ£€æµ‹: \$FILE_TYPE"
                            
                            if echo "\$FILE_TYPE" | grep -q "Zip archive"; then
                                ARCHIVE_FILE="BUILD_ARCHIVE.zip"
                                mv BUILD_ARCHIVE "\$ARCHIVE_FILE"
                                echo "âœ… æ£€æµ‹ä¸ºZIPæ–‡ä»¶ï¼Œé‡å‘½åä¸º: \$ARCHIVE_FILE"
                            elif echo "\$FILE_TYPE" | grep -q "gzip compressed"; then
                                ARCHIVE_FILE="BUILD_ARCHIVE.tar.gz"
                                mv BUILD_ARCHIVE "\$ARCHIVE_FILE"
                                echo "âœ… æ£€æµ‹ä¸ºTAR.GZæ–‡ä»¶ï¼Œé‡å‘½åä¸º: \$ARCHIVE_FILE"
                            elif echo "\$FILE_TYPE" | grep -q "POSIX tar archive"; then
                                ARCHIVE_FILE="BUILD_ARCHIVE.tar"
                                mv BUILD_ARCHIVE "\$ARCHIVE_FILE"
                                echo "âœ… æ£€æµ‹ä¸ºTARæ–‡ä»¶ï¼Œé‡å‘½åä¸º: \$ARCHIVE_FILE"
                            else
                                ARCHIVE_FILE="BUILD_ARCHIVE"
                                echo "âš ï¸  æ— æ³•è¯†åˆ«æ–‡ä»¶ç±»å‹ï¼Œä½¿ç”¨é»˜è®¤åç§°: \$ARCHIVE_FILE"
                            fi
                        fi
                        
                        echo "æœ€ç»ˆä½¿ç”¨çš„æ–‡ä»¶å: \$ARCHIVE_FILE"
                        echo "ARCHIVE_FILE=\$ARCHIVE_FILE" > archive_info.env
                    """
                    
                    // è¯»å–æ–‡ä»¶åä¿¡æ¯
                    def archiveInfo = readFile('archive_info.env').trim()
                    def archiveFile = archiveInfo.split('=')[1]
                    env.ACTUAL_ARCHIVE_FILE = archiveFile
                    
                    echo "ç¡®å®šçš„å½’æ¡£æ–‡ä»¶: ${env.ACTUAL_ARCHIVE_FILE}"
                    
                    // æ£€æµ‹æ–‡ä»¶ç±»å‹å¹¶è§£å‹ - ä½¿ç”¨ Pipeline Utility Steps
                    script {
                        def uploadedArchive = env.ACTUAL_ARCHIVE_FILE
                        
                        echo "ğŸ“‹ æ–‡ä»¶ä¿¡æ¯:"
                        sh "ls -lh '${uploadedArchive}'"
                        
                        echo "ğŸ“‚ å¼€å§‹è§£å‹æ–‡ä»¶: ${uploadedArchive}"
                        
                        // æ ¹æ®æ–‡ä»¶æ‰©å±•åä½¿ç”¨é€‚å½“çš„ Pipeline Utility Steps
                        try {
                            if (uploadedArchive.endsWith('.zip')) {
                                echo "ä½¿ç”¨ Pipeline Utility Steps unzip è§£å‹ ZIP æ–‡ä»¶"
                                unzip zipFile: uploadedArchive, quiet: false
                                echo "âœ… ZIP æ–‡ä»¶è§£å‹å®Œæˆ"
                            } else if (uploadedArchive.endsWith('.tar.gz') || uploadedArchive.endsWith('.tgz')) {
                                echo "ä½¿ç”¨ Pipeline Utility Steps untar è§£å‹ TAR.GZ æ–‡ä»¶"
                                untar file: uploadedArchive, compression: 'gzip', quiet: false
                                echo "âœ… TAR.GZ æ–‡ä»¶è§£å‹å®Œæˆ"
                            } else if (uploadedArchive.endsWith('.tar')) {
                                echo "ä½¿ç”¨ Pipeline Utility Steps untar è§£å‹ TAR æ–‡ä»¶"
                                untar file: uploadedArchive, quiet: false
                                echo "âœ… TAR æ–‡ä»¶è§£å‹å®Œæˆ"
                            } else {
                                echo "âš ï¸  æœªçŸ¥æ–‡ä»¶æ ¼å¼ï¼Œå°è¯•é€šç”¨è§£å‹æ–¹æ³•"
                                // å…ˆå°è¯•ä½œä¸º ZIP æ–‡ä»¶
                                try {
                                    echo "å°è¯•æŒ‰ ZIP æ ¼å¼è§£å‹"
                                    unzip zipFile: uploadedArchive, quiet: false
                                    echo "âœ… æŒ‰ ZIP æ ¼å¼è§£å‹æˆåŠŸ"
                                } catch (Exception zipEx) {
                                    echo "ZIP è§£å‹å¤±è´¥ï¼Œå°è¯•æŒ‰ TAR æ ¼å¼è§£å‹"
                                    try {
                                        untar file: uploadedArchive, quiet: false
                                        echo "âœ… æŒ‰ TAR æ ¼å¼è§£å‹æˆåŠŸ"
                                    } catch (Exception tarEx) {
                                        echo "TAR è§£å‹å¤±è´¥ï¼Œå°è¯•æŒ‰ TAR.GZ æ ¼å¼è§£å‹"
                                        untar file: uploadedArchive, compression: 'gzip', quiet: false
                                        echo "âœ… æŒ‰ TAR.GZ æ ¼å¼è§£å‹æˆåŠŸ"
                                    }
                                }
                            }
                        } catch (Exception e) {
                            echo "âŒ Pipeline Utility Steps è§£å‹å¤±è´¥: ${e.getMessage()}"
                            echo "å›é€€åˆ°ä¼ ç»Ÿæ–¹æ³•è§£å‹..."
                            
                            // å›é€€åˆ°ä¼ ç»Ÿå‘½ä»¤è¡Œè§£å‹
                            if (uploadedArchive.endsWith('.zip')) {
                                echo "ä½¿ç”¨ Python è§£å‹ ZIP æ–‡ä»¶"
                                sh '''
                                    python3 -c "
import zipfile
import sys
try:
    with zipfile.ZipFile('${uploadedArchive}', 'r') as zip_ref:
        zip_ref.extractall('.')
    print('âœ… Python ZIP è§£å‹æˆåŠŸ')
except Exception as e:
    print(f'âŒ Python ZIP è§£å‹å¤±è´¥: {e}')
    sys.exit(1)
                                    "
                                '''
                            } else if (uploadedArchive.endsWith('.tar.gz') || uploadedArchive.endsWith('.tgz')) {
                                echo "ä½¿ç”¨ tar è§£å‹ TAR.GZ æ–‡ä»¶"
                                sh "tar -xzf '${uploadedArchive}'"
                            } else if (uploadedArchive.endsWith('.tar')) {
                                echo "ä½¿ç”¨ tar è§£å‹ TAR æ–‡ä»¶"
                                sh "tar -xf '${uploadedArchive}'"
                            }
                        }
                        
                        echo "ğŸ“ è§£å‹åå·¥ä½œç©ºé—´å†…å®¹:"
                        sh "ls -la"
                    }
                    
                    // éªŒè¯æ„å»ºç›®å½•å’Œæ–‡ä»¶æ˜¯å¦å­˜åœ¨
                    sh """
                        if [ ! -d "${BUILD_CONTEXT_PATH}" ]; then
                            echo "âŒ é”™è¯¯: æ„å»ºç›®å½• ${BUILD_CONTEXT_PATH} ä¸å­˜åœ¨"
                            echo "ğŸ“ å½“å‰ç›®å½•å†…å®¹:"
                            find . -type d -maxdepth 2
                            exit 1
                        fi
                        
                        if [ ! -f "${DOCKERFILE_PATH}" ]; then
                            echo "âŒ é”™è¯¯: Dockerfile ${DOCKERFILE_PATH} ä¸å­˜åœ¨"
                            echo "ğŸ“ æ„å»ºç›®å½•å†…å®¹:"
                            ls -la ${BUILD_CONTEXT_PATH}/
                            exit 1
                        fi
                        
                        echo "âœ… æ„å»ºæ–‡ä»¶éªŒè¯é€šè¿‡"
                        echo "ğŸ“ æ„å»ºç›®å½•å†…å®¹:"
                        ls -la ${BUILD_CONTEXT_PATH}/
                    """
                }
            }
        }

        stage("æ„å»ºå‡†å¤‡") {
            steps {
                script {
                    echo "ğŸ”§ æ„å»ºå‡†å¤‡é˜¶æ®µ"
                    
                    // ç”Ÿæˆå”¯ä¸€æ„å»ºæ ‡è¯†ç¬¦ï¼ˆè§£å†³å¹¶å‘æ„å»ºé—®é¢˜ï¼‰
                    echo "ğŸ”„ æ­£åœ¨ç”Ÿæˆå”¯ä¸€æ„å»ºæ ‡è¯†ç¬¦..."
                    def uniqueBuildId = generateUniqueBuildId()
                    echo "âœ… å”¯ä¸€æ„å»ºIDå·²ç”Ÿæˆ: ${uniqueBuildId}"
                    
                    // ç”Ÿæˆé•œåƒæ ‡ç­¾ï¼ˆä¼ å…¥uniqueBuildIdé¿å…å¾ªç¯ä¾èµ–ï¼‰
                    echo "ğŸ”„ æ­£åœ¨ç”Ÿæˆé•œåƒæ ‡ç­¾..."
                    def imageTag = generateImageTag(uniqueBuildId)
                    echo "âœ… é•œåƒæ ‡ç­¾å·²ç”Ÿæˆ: ${imageTag}"
                    
                    // è®¾ç½®ç¯å¢ƒå˜é‡ï¼ˆä½¿ç”¨scriptå—å†…çš„æ–¹å¼ï¼‰
                    env.UNIQUE_BUILD_ID = uniqueBuildId
                    env.IMAGE_TAG = imageTag
                    
                    // éªŒè¯ç¯å¢ƒå˜é‡è®¾ç½®
                    echo "ğŸ” éªŒè¯ç¯å¢ƒå˜é‡è®¾ç½®:"
                    echo "   UNIQUE_BUILD_ID = ${env.UNIQUE_BUILD_ID}"
                    echo "   IMAGE_TAG = ${env.IMAGE_TAG}"
                    
                    echo "åº”ç”¨åç§°: ${params.APP_NAME}"
                    echo "åº”ç”¨ç‰ˆæœ¬: ${params.APP_VERSION}" 
                    echo "é•œåƒåç§°: ${IMAGE_NAME}"
                    echo "é•œåƒæ ‡ç­¾: ${imageTag}"
                    echo "å”¯ä¸€æ„å»ºID: ${uniqueBuildId}"
                    echo "Harbor ä»“åº“: ${HARBOR_REGISTRY}"
                    echo "é¡¹ç›®: ${HARBOR_PROJECT}"
                }
                
                // åœ¨scriptå—å¤–éƒ¨ä½¿ç”¨shï¼Œæ­¤æ—¶ç¯å¢ƒå˜é‡åº”è¯¥å¯ç”¨
                sh '''
                    echo "=== æ„å»ºä¿¡æ¯ ==="
                    echo "Jenkinsæ„å»ºå·: ${BUILD_NUMBER}"
                    echo "å”¯ä¸€æ„å»ºID: ${UNIQUE_BUILD_ID}"
                    echo "é•œåƒæ ‡ç­¾: ${IMAGE_TAG}"
                    echo "æ„å»ºæ—¶é—´: $(date)"
                    echo "æ„å»ºèŠ‚ç‚¹: $(hostname)"
                    echo "Jenkins URL: ${JENKINS_URL}"
                    echo "åŸå§‹æ–‡ä»¶å: ${BUILD_ARCHIVE_FILENAME:-'æœªè®¾ç½®'}"
                    echo "å®é™…ä½¿ç”¨æ–‡ä»¶: ${ACTUAL_ARCHIVE_FILE}"
                    echo "æ„å»ºç­–ç•¥: ${IMAGE_TAG_STRATEGY}"
                '''
            }
        }

        stage("ä½¿ç”¨ Kaniko æ„å»ºå¹¶æ¨é€é•œåƒ") {
            steps {
                container(name: 'kaniko', shell: '/busybox/sh') {
                    sh '''#!/busybox/sh
                        echo "ğŸš€ å¼€å§‹ä½¿ç”¨ Kaniko æ„å»º Docker é•œåƒ"
                        echo "ğŸ“‹ æ„å»ºæ ‡è¯†ä¿¡æ¯:"
                        echo "   Jenkinsæ„å»ºå·: ${BUILD_NUMBER}"
                        echo "   å”¯ä¸€æ„å»ºID: ${UNIQUE_BUILD_ID}"
                        echo "   é•œåƒæ ‡ç­¾: ${IMAGE_TAG}"
                        
                        # æ˜¾ç¤º Kaniko ç‰ˆæœ¬
                        /kaniko/executor version
                        
                        # æ˜¾ç¤ºæ„å»ºä¸Šä¸‹æ–‡
                        echo "ğŸ“‚ æ„å»ºä¸Šä¸‹æ–‡å†…å®¹:"
                        ls -la ${BUILD_CONTEXT_PATH}/
                        
                        # æ‰§è¡Œé•œåƒæ„å»ºå’Œæ¨é€
                        echo "ğŸ”¨ å¼€å§‹æ„å»ºé•œåƒ: ${IMAGE_NAME}:${IMAGE_TAG}"
                        
                        /kaniko/executor \\
                            --dockerfile=${DOCKERFILE_PATH} \\
                            --context=${BUILD_CONTEXT_PATH} \\
                            --destination=${IMAGE_NAME}:${IMAGE_TAG} \\
                            --destination=${IMAGE_NAME}:latest \\
                            --cache=true \\
                            --cache-ttl=24h \\
                            --cleanup
                        
                        echo "âœ… é•œåƒæ„å»ºå¹¶æ¨é€å®Œæˆ"
                        echo "ğŸ“¦ æ¨é€çš„é•œåƒ:"
                        echo "   - ${IMAGE_NAME}:${IMAGE_TAG}"
                        echo "   - ${IMAGE_NAME}:latest"
                        echo "ğŸ†” å”¯ä¸€æ„å»ºæ ‡è¯†: ${UNIQUE_BUILD_ID}"
                    '''
                }
            }
        }

        stage("éªŒè¯é•œåƒæ¨é€") {
            steps {
                script {
                    echo "ğŸ” éªŒè¯é•œåƒæ˜¯å¦æˆåŠŸæ¨é€åˆ° Harbor"
                    
                    // è¿™é‡Œå¯ä»¥æ·»åŠ éªŒè¯é€»è¾‘ï¼Œæ¯”å¦‚è°ƒç”¨ Harbor API æ£€æŸ¥é•œåƒæ˜¯å¦å­˜åœ¨
                    sh """
                        echo "é•œåƒæ¨é€éªŒè¯:"
                        echo "ä»“åº“åœ°å€: ${HARBOR_REGISTRY}"
                        echo "é¡¹ç›®: ${HARBOR_PROJECT}"
                        echo "é•œåƒ: ${params.APP_NAME}:${env.IMAGE_TAG}"
                        echo "å”¯ä¸€æ„å»ºID: ${env.UNIQUE_BUILD_ID}"
                        
                        # å¯ä»¥æ·»åŠ  Harbor API è°ƒç”¨æ¥éªŒè¯é•œåƒ
                        # curl -u admin:password ${HARBOR_REGISTRY}/api/v2.0/projects/${HARBOR_PROJECT}/repositories/${params.APP_NAME}/artifacts
                    """
                }
            }
        }
    }

    post {
        always {
            script {
                echo "ğŸ§¹ æ¸…ç†æ„å»ºç¯å¢ƒ"
                echo "ğŸ“‹ æ„å»ºå®Œæˆä¿¡æ¯:"
                echo "   Jenkinsæ„å»ºå·: ${BUILD_NUMBER}"
                echo "   å”¯ä¸€æ„å»ºID: ${env.UNIQUE_BUILD_ID}"
                echo "   é•œåƒæ ‡ç­¾: ${env.IMAGE_TAG}"
            }
        }
        success {
            script {
                echo "ğŸ‰ æ„å»ºæˆåŠŸ!"
                echo "ğŸ“¦ é•œåƒå·²æ¨é€åˆ°: ${IMAGE_NAME}:${env.IMAGE_TAG}"
                echo "ğŸ†” å”¯ä¸€æ„å»ºæ ‡è¯†: ${env.UNIQUE_BUILD_ID}"
                
                // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æˆåŠŸé€šçŸ¥ï¼Œæ¯”å¦‚å‘é€åˆ°ä¼ä¸šå¾®ä¿¡ã€é’‰é’‰ç­‰
                // notifySuccess()
            }
        }
        failure {
            script {
                echo "âŒ æ„å»ºå¤±è´¥!"
                echo "ğŸ†” å¤±è´¥çš„æ„å»ºæ ‡è¯†: ${env.UNIQUE_BUILD_ID}"
                
                // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ å¤±è´¥é€šçŸ¥
                // notifyFailure()
            }
        }
    }
}

// ç”Ÿæˆå”¯ä¸€æ„å»ºæ ‡è¯†ç¬¦çš„å‡½æ•°ï¼ˆè§£å†³å¹¶å‘æ„å»ºé—®é¢˜ï¼‰
def generateUniqueBuildId() {
    try {
        // ç»„åˆå¤šç§å…ƒç´ æ¥ç¡®ä¿å”¯ä¸€æ€§
        def timestamp = new Date().format('yyyyMMdd-HHmmss-SSS')
        def randomId = java.util.UUID.randomUUID().toString().split('-')[0]
        def buildNumber = env.BUILD_NUMBER ?: "0"
        def jobName = env.JOB_NAME?.replaceAll('[^a-zA-Z0-9]', '') ?: "job"
        
        // æ ¼å¼: {job}-{build}-{timestamp}-{random}
        def uniqueId = "${jobName}-${buildNumber}-${timestamp}-${randomId}".toLowerCase()
        echo "ğŸ”§ ç”Ÿæˆçš„å”¯ä¸€ID: ${uniqueId}"
        return uniqueId
    } catch (Exception e) {
        echo "âŒ ç”Ÿæˆå”¯ä¸€IDå¤±è´¥: ${e.getMessage()}"
        // å›é€€æ–¹æ¡ˆï¼šä½¿ç”¨æ—¶é—´æˆ³
        def fallbackId = "job-${env.BUILD_NUMBER ?: '0'}-${new Date().format('yyyyMMddHHmmssSSS')}"
        echo "ğŸ”„ ä½¿ç”¨å›é€€ID: ${fallbackId}"
        return fallbackId
    }
}

// ç”Ÿæˆé•œåƒæ ‡ç­¾çš„å‡½æ•°ï¼ˆæ”¯æŒå”¯ä¸€æ€§ä¿è¯ï¼‰
def generateImageTag(uniqueId = null) {
    def strategy = params.IMAGE_TAG_STRATEGY ?: 'version-build-unique'
    def actualUniqueId = uniqueId ?: generateUniqueBuildId()
    
    switch(strategy) {
        case 'version-build-unique':
            // ä½¿ç”¨å”¯ä¸€IDè€Œä¸æ˜¯BUILD_NUMBERï¼Œç¡®ä¿å¹¶å‘å®‰å…¨
            def shortId = actualUniqueId.split('-')[-1] // å–æœ€åä¸€æ®µéšæœºID
            return "${params.APP_VERSION}-${BUILD_NUMBER}-${shortId}"
            
        case 'version-build':
            // ä¼ ç»Ÿæ–¹å¼ï¼Œå¯èƒ½åœ¨å¹¶å‘æ—¶æœ‰å†²çª
            return "${params.APP_VERSION}-${BUILD_NUMBER}"
            
        case 'timestamp':
            // ä½¿ç”¨ç²¾ç¡®æ—¶é—´æˆ³ï¼Œå¹¶å‘å®‰å…¨
            return "${params.APP_VERSION}-${new Date().format('yyyyMMdd-HHmmss-SSS')}"
            
        case 'latest':
            return 'latest'
            
        default:
            // é»˜è®¤ä½¿ç”¨å”¯ä¸€æ–¹å¼
            def shortId = actualUniqueId.split('-')[-1]
            return "${params.APP_VERSION}-${BUILD_NUMBER}-${shortId}"
    }
} 