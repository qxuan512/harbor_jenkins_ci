pipeline {
    agent {
        kubernetes {
            yaml '''
kind: Pod
spec:
  containers:
  - name: docker-buildx
    image: docker:25-dind
    securityContext:
      privileged: true
    volumeMounts:
      - name: jenkins-docker-cfg
        mountPath: /root/.docker
    env:
    - name: DOCKER_HOST
      value: tcp://localhost:2376
    - name: DOCKER_TLS_CERTDIR
      value: ""
  - name: docker-daemon
    image: docker:25-dind
    securityContext:
      privileged: true
    env:
    - name: DOCKER_TLS_CERTDIR
      value: ""
  volumes:
  - name: jenkins-docker-cfg
    projected:
      sources:
      - secret:
          name: harbor-credentials
          items:
            - key: .dockerconfigjson
              path: config.json
            '''
        }
    }

    parameters {
        string(name: 'APP_NAME', defaultValue: 'iot-driver', description: 'åº”ç”¨åç§°')
        string(name: 'APP_VERSION', defaultValue: '1.0.0', description: 'åº”ç”¨ç‰ˆæœ¬')
        string(name: 'BUILD_CONTEXT', defaultValue: 'example_direct_upload', description: 'æ„å»ºä¸Šä¸‹æ–‡ç›®å½•')
        choice(name: 'IMAGE_TAG_STRATEGY', choices: ['version-build', 'timestamp', 'latest'], description: 'é•œåƒæ ‡ç­¾ç­–ç•¥')
        // å¤šå¹³å°å‚æ•° - æ”¯æŒçœŸæ­£çš„å¤šæ¶æ„
        choice(name: 'BUILD_PLATFORMS', 
               choices: ['linux/amd64,linux/arm64', 'linux/amd64', 'linux/arm64'], 
               description: 'æ„å»ºå¹³å°é€‰æ‹© (å¤šå¹³å°ç”¨é€—å·åˆ†éš”)')
        string(name: 'BUILD_UNIQUE_ID', defaultValue: '', description: 'æ„å»ºå”¯ä¸€æ ‡è¯†ç¬¦')
        stashedFile(name: 'BUILD_ARCHIVE', description: 'ä¸Šä¼ åŒ…å«æ„å»ºä¸Šä¸‹æ–‡çš„å‹ç¼©æ–‡ä»¶')
    }

    environment {
        HARBOR_REGISTRY = "registry.test.shifu.dev"
        HARBOR_PROJECT = "test-project"
        DOCKER_USER = "admin"
        DOCKER_PASS = 'harbor-credentials'
        
        IMAGE_NAME = "${HARBOR_REGISTRY}/${HARBOR_PROJECT}/${params.APP_NAME}"
        IMAGE_TAG = generateImageTag()
        
        DOCKERFILE_PATH = "${params.BUILD_CONTEXT}/Dockerfile"
        BUILD_CONTEXT_PATH = "${params.BUILD_CONTEXT}"
        
        BUILD_PLATFORMS = "${params.BUILD_PLATFORMS}"
    }

    stages {
        stage("æ¸…ç†å·¥ä½œç©ºé—´") {
            steps {
                cleanWs()
            }
        }

        stage("å¤„ç†ä¸Šä¼ æ–‡ä»¶") {
            steps {
                script {
                    echo "ğŸ“¦ å¼€å§‹å¤„ç†ä¸Šä¼ çš„æ„å»ºæ–‡ä»¶"
                    
                    unstash 'BUILD_ARCHIVE'
                    
                    // æ£€æŸ¥æ–‡ä»¶å¹¶è§£å‹
                    def uploadedArchive = env.BUILD_ARCHIVE_FILENAME ?: 'BUILD_ARCHIVE'
                    
                    echo "ğŸ“‚ å¼€å§‹è§£å‹æ–‡ä»¶: ${uploadedArchive}"
                    
                    // æ ¹æ®æ–‡ä»¶ç±»å‹è§£å‹
                    if (uploadedArchive.endsWith('.zip')) {
                        unzip zipFile: uploadedArchive, quiet: false
                    } else if (uploadedArchive.endsWith('.tar.gz') || uploadedArchive.endsWith('.tgz')) {
                        untar file: uploadedArchive, compression: 'gzip', quiet: false
                    } else if (uploadedArchive.endsWith('.tar')) {
                        untar file: uploadedArchive, quiet: false
                    } else {
                        // å°è¯•é€šç”¨è§£å‹æ–¹æ³•
                        try {
                            unzip zipFile: uploadedArchive, quiet: false
                        } catch (Exception zipEx) {
                            untar file: uploadedArchive, compression: 'gzip', quiet: false
                        }
                    }
                    
                    // éªŒè¯æ„å»ºæ–‡ä»¶
                    sh """
                        if [ ! -d "${BUILD_CONTEXT_PATH}" ]; then
                            echo "âŒ é”™è¯¯: æ„å»ºç›®å½• ${BUILD_CONTEXT_PATH} ä¸å­˜åœ¨"
                            find . -type d -maxdepth 2
                            exit 1
                        fi
                        
                        if [ ! -f "${DOCKERFILE_PATH}" ]; then
                            echo "âŒ é”™è¯¯: Dockerfile ${DOCKERFILE_PATH} ä¸å­˜åœ¨"
                            ls -la ${BUILD_CONTEXT_PATH}/
                            exit 1
                        fi
                        
                        echo "âœ… æ„å»ºæ–‡ä»¶éªŒè¯é€šè¿‡"
                        echo "ğŸ“ æ„å»ºç›®å½•å†…å®¹:"
                        ls -la ${BUILD_CONTEXT_PATH}/
                    """
                }
            }
        }

        stage("è®¾ç½® Docker Buildx") {
            steps {
                container('docker-buildx') {
                    script {
                        echo "ğŸ”§ è®¾ç½® Docker Buildx å¤šå¹³å°æ„å»º"
                        
                        sh '''
                            # ç­‰å¾… Docker daemon å¯åŠ¨
                            timeout 30s sh -c 'until docker info > /dev/null 2>&1; do sleep 1; done'
                            
                            # å¯ç”¨å®éªŒæ€§åŠŸèƒ½
                            mkdir -p ~/.docker
                            echo '{"experimental": "enabled"}' > ~/.docker/config.json
                            
                            # å®‰è£… QEMU ç”¨äºæ¨¡æ‹Ÿ
                            docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
                            
                            # åˆ›å»ºå¹¶ä½¿ç”¨ buildx æ„å»ºå™¨
                            docker buildx create --name multiarch-builder --driver docker-container --use || true
                            docker buildx use multiarch-builder
                            docker buildx inspect --bootstrap
                            
                            # æ˜¾ç¤ºæ”¯æŒçš„å¹³å°
                            echo "ğŸ—ï¸  æ”¯æŒçš„æ„å»ºå¹³å°:"
                            docker buildx ls
                        '''
                    }
                }
            }
        }

        stage("æ„å»ºå¤šå¹³å°é•œåƒ") {
            steps {
                container('docker-buildx') {
                    script {
                        echo "ğŸš€ å¼€å§‹å¤šå¹³å°é•œåƒæ„å»º"
                        
                        sh """
                            echo "ğŸ—ï¸  æ„å»ºé…ç½®"
                            echo "æ„å»ºå¹³å°: ${BUILD_PLATFORMS}"
                            echo "é•œåƒåç§°: ${IMAGE_NAME}"
                            echo "é•œåƒæ ‡ç­¾: ${IMAGE_TAG}"
                            echo "Dockerfile: ${DOCKERFILE_PATH}"
                            echo "æ„å»ºä¸Šä¸‹æ–‡: ${BUILD_CONTEXT_PATH}"
                            
                            # æ˜¾ç¤ºæ„å»ºä¸Šä¸‹æ–‡
                            echo "ğŸ“‚ æ„å»ºä¸Šä¸‹æ–‡å†…å®¹:"
                            ls -la ${BUILD_CONTEXT_PATH}/
                            
                            # æ„å»ºå¹¶æ¨é€å¤šå¹³å°é•œåƒ
                            echo "ğŸ”¨ å¼€å§‹æ„å»ºå¤šå¹³å°é•œåƒ"
                            docker buildx build \\
                                --platform ${BUILD_PLATFORMS} \\
                                --file ${DOCKERFILE_PATH} \\
                                --context ${BUILD_CONTEXT_PATH} \\
                                --tag ${IMAGE_NAME}:${IMAGE_TAG} \\
                                --tag ${IMAGE_NAME}:latest \\
                                --push \\
                                --progress plain
                            
                            echo "âœ… å¤šå¹³å°é•œåƒæ„å»ºå¹¶æ¨é€å®Œæˆ"
                            
                            # æ˜¾ç¤ºæ¨é€çš„é•œåƒä¿¡æ¯
                            echo "ğŸ“¦ æ¨é€çš„å¤šå¹³å°é•œåƒ:"
                            echo "   - ${IMAGE_NAME}:${IMAGE_TAG} (${BUILD_PLATFORMS})"
                            echo "   - ${IMAGE_NAME}:latest (${BUILD_PLATFORMS})"
                            
                            # æ£€æŸ¥ manifest
                            echo "ğŸ” éªŒè¯å¤šå¹³å° manifest:"
                            docker buildx imagetools inspect ${IMAGE_NAME}:${IMAGE_TAG}
                        """
                    }
                }
            }
        }

        stage("éªŒè¯å¤šå¹³å°é•œåƒ") {
            steps {
                container('docker-buildx') {
                    script {
                        echo "ğŸ” éªŒè¯å¤šå¹³å°é•œåƒ"
                        
                        sh """
                            echo "ğŸ“‹ é•œåƒéªŒè¯ä¿¡æ¯:"
                            echo "ä»“åº“åœ°å€: ${HARBOR_REGISTRY}"
                            echo "é¡¹ç›®: ${HARBOR_PROJECT}"
                            echo "é•œåƒ: ${params.APP_NAME}:${IMAGE_TAG}"
                            echo "æ”¯æŒå¹³å°: ${BUILD_PLATFORMS}"
                            
                            # æ£€æŸ¥æ¯ä¸ªå¹³å°çš„é•œåƒ
                            echo "ğŸ” æ£€æŸ¥å„å¹³å°é•œåƒè¯¦æƒ…:"
                            docker buildx imagetools inspect ${IMAGE_NAME}:${IMAGE_TAG} --raw
                            
                            echo "âœ… å¤šå¹³å°é•œåƒéªŒè¯å®Œæˆ"
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                echo "ğŸ§¹ æ¸…ç†æ„å»ºç¯å¢ƒ"
            }
        }
        success {
            script {
                echo "ğŸ‰ å¤šå¹³å°æ„å»ºæˆåŠŸ!"
                echo "ğŸ“¦ å¤šå¹³å°é•œåƒå·²æ¨é€åˆ°: ${IMAGE_NAME}:${IMAGE_TAG}"
                echo "ğŸ“¦ æ”¯æŒå¹³å°: ${BUILD_PLATFORMS}"
                echo "ğŸ”— å¯é€šè¿‡ä»¥ä¸‹å‘½ä»¤æ£€æŸ¥: docker buildx imagetools inspect ${IMAGE_NAME}:${IMAGE_TAG}"
            }
        }
        failure {
            script {
                echo "âŒ å¤šå¹³å°æ„å»ºå¤±è´¥!"
            }
        }
    }
}

// ç”Ÿæˆé•œåƒæ ‡ç­¾çš„å‡½æ•°
def generateImageTag() {
    def strategy = params.IMAGE_TAG_STRATEGY ?: 'version-build'
    
    switch(strategy) {
        case 'version-build':
            return "${params.APP_VERSION}"
        case 'timestamp':
            return "${params.APP_VERSION}-${new Date().format('yyyyMMdd-HHmmss')}"
        case 'latest':
            return 'latest'
        default:
            return "${params.APP_VERSION}"
    }
} 